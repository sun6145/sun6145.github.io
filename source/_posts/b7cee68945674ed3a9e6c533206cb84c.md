---
layout: post
title: CAS原理与JUC原子类
abbrlink: b7cee68945674ed3a9e6c533206cb84c
tags:
  - juc
categories:
  - JDK
  - 多线程编程
date: 1745339269946
updated: 1746417800413
---

介绍 CAS 的原理和弊端，然后介绍基于 CAS 实现的 JUC 原子类。

<!-- more -->

***

由于 JVM 的 Synchronized 重量级锁涉及操作系统（如 Linux）内核态下互斥锁的使用，因此其线程阻塞和唤醒都涉及进程在用户态到内核态的频繁切换，导致重量级锁开销大、性能低。而 JVM 的 Synchronized 轻量级锁使用 CAS（Compare And Swap，比较并交换）进行自旋抢锁，**CAS 是 CPU 指令级的原子操作，并处于用户态下，所以 JVM 轻量级锁的开销较小**。

## 什么是 CAS

JDK 5 所增加的 JUC（java.util.concurrent）并发包对操作系统的底层 CAS 原子操作进行了封装，为上层 Java 程序提供了 CAS 操作的 API。

## Unsafe 类中的 CAS 方法

Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等。Unsafe 大量的方法都是 native 方法，基于 C++语言实现，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。

Unsafe 类的全限定名为 **sun.misc.Unsafe**，从名字中可以看出这个类对普通程序员来说是“危险”的，一般的应用开发都不会涉及此类，**Java 官方也不建议直接在应用程序中使用这些类**。

为什么此类取名为 Unsafe 呢？由于使用 Unsafe 类可以像 C 语言一样使用指针操作内存空间，这无疑增加了指针相关问题、内存泄漏问题出现的概率。总之，在程序中过度使用 Unsafe 类会使得程序出错的概率变大，使得安全的语言 Java 变得不再安全，因此对 Unsafe 的使用一定要慎重。

**操作系统层面的 CAS 是一条 CPU 的原子指令（cmpxchg 指令），正是由于该指令具备原子性，因此使用 CAS 操作数据时不会造成数据不一致的问题**，Unsafe 提供的 CAS 方法直接通过 native 方式（封装 C++代码）调用了底层的 CPU 指令 cmpxchg。

完成 Java 应用层的 CAS 操作主要涉及 Unsafe 方法的调用，具体如下：

1. 获取 Unsafe 实例。
2. 调用 Unsafe 提供的 CAS 方法，这些方法主要封装了底层 CPU 的 CAS 原子操作。
3. 调用 Unsafe 提供的字段偏移量方法，这些方法用于获取对象中的字段（属性）偏移量，此偏移量值需要作为参数提供给 CAS 操作。

### 获取 Unsafe 实例

Unsafe 类是一个 final 修饰的不允许继承的最终类，而且其构造函数是 private 类型的方法，具体的源码如下：

```java
public final class Unsafe {
    private static final Unsafe theUnsafe;
    public static final int INVALID_FIELD_OFFSET = -1;

    private static native void registerNatives();
    // 构造函数是private的，不允许外部实例化
    private Unsafe() {
    }
    ...
}
```

因此，我们无法在外部对 Unsafe 进行实例化，那么怎么获取 Unsafe 的实例呢？可以通过反射的方式自定义地获取 Unsafe 实例的辅助方法，代码如下：

```java
// 省略import
public class JvmUtil {
    //自定义地获取Unsafe实例的辅助方法
    public static Unsafe getUnsafe() {
        try {
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true);
            return (Unsafe) theUnsafe.get(null);
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } // 省略不相干代码
}
```

### 调用 Unsafe 提供的 CAS 方法

Unsafe 提供的 CAS 方法包含 4 个操作数——字段所在的对象、字段内存位置、预期原值及新值。**在执行 Unsafe 的 CAS 方法时，这些方法首先将内存位置的值与预期值（旧的值）比较，如果相匹配，那么 CPU 会**
**自动将该内存位置的值更新为新值，并返回 true；如果不匹配，CPU 不做任何操作，并返回 false**。

Unsafe 的 CAS 操作会将第一个参数（对象的指针、地址）与第二个参数（字段偏移量）组合在一起，计算出最终的内存操作地址。

```java
/**
 * 定义在Unsafe类中的三个“比较并交换”原子方法。
 *
 * @param o 需要操作的字段所在的对象
 * @param offset 需要操作的字段的偏移量（相对的，相对于对象头）
 * @param expected 期望值（旧的值）
 * @param update 更新值（新的值）
 * @return true 更新成功 | false 更新失败
 */
public final native boolean compareAndSwapObject(
    Object o, long offset, Object expected, Object update);

public final native boolean compareAndSwapInt(
    Object o, long offset, int expected, int update);

public final native boolean compareAndSwapLong(
    Object o, long offset, long expected, long update);
```

### 调用 Unsafe 提供的偏移量相关

Unsafe 提供的获取字段（属性）偏移量的相关操作主要如下：

- staticFieldOffset()方法用于 **获取静态属性 Field 在 Class 对象中的偏移量**，在 CAS 中操作静态属性时会用到这个偏移量。
- objectFieldOffset()方法用于 **获取非静态 Field（非静态属性）在 Object 实例中的偏移量**，在 CAS 中操作对象的非静态属性时会用到这个偏移量。

```java
 /**
 * 定义在Unsafe类中的几个获取字段偏移量的方法
 * @param o 需要操作字段的反射
 * @return 字段的偏移量
 */

 public native long staticFieldOffset(Field field);

 public native long objectFieldOffset(Field field);
```

一个获取非静态 Field（非静态属性）在 Object 实例中的偏移量的示例代码如下：

```java
static {
    try {
        // 获取反射的Field对象
        Field field = OptimisticLockingPlus.class.getDeclaredField("value");

        // 取得内存偏移
        valueOffset = unsafe.objectFieldOffset(field);
    } catch (Exception ex) {
        throw new Error(ex);
    }
}
```

## 使用 CAS 进行无锁编程

CAS 是一种无锁算法，该算法关键依赖两个值——期望值（旧值）和新值，底层 CPU 利用原子操作判断内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。

使用 CAS 进行无锁编程的步骤大致如下：

1. 获得字段的期望值（oldValue）。
2. 计算出需要替换的新值（newValue）。
3. 通过 CAS 将新值（newValue）放在字段的内存地址上，如果 CAS 失败就重复第（1）步到第（2）步，一直到 CAS 成功，这种重复俗称 **CAS 自旋**。

使用 CAS 进行无锁编程的伪代码如下：

```java
do {
    获得字段的期望值（oldValue）;
    计算出需要替换的新值（newValue）;
} while (!CAS(内存地址，oldValue，newValue))

```

假如某个内存地址（某对象的属性）的值为 100，现在有两个线程（线程 A 和线程 B）使用 CAS 无锁编程对该内存地址进行更新，线程 A 欲将其值更新为 200，线程 B 欲将其值更新为 300，线程是并发执行的，谁都有可能先执行。但是 CAS 是原子操作，对同一个内存地址的 CAS 操作在同一时刻只能执行一个。因此，在这个例
子中，要么线程 A 先执行，要么线程 B 先执行。

- 假设线程 A 的 CAS(100,200)执行在前，由于内存地址的旧值 100 与该 CAS 的期望值 100 相等，因此线程 A 会操作成功，内存地址的值被更新为 200。
- 接下来执行线程 B 的 CAS(100,300)操作，此时内存地址的值为 200，不等于 CAS 的期望值 100，线程 B 操作失败。线程 B 只能自旋，开始新的循环，这一轮循环首先获取到内存地址的值 200，然后进行 CAS(200,300)操作，这一次内存地址的值与 CAS 的预期值（oldValue）相等，线程 B 操作成功。

当 CAS 将内存地址的值与预期值进行比较时，如果相等，就证明内存地址的值没有被修改，可以替换成新值，然后继续往下运行；如果不相等，就说明内存地址的值已经被修改，放弃替换操作，然后重新自旋。当并发修改的线程少，冲突出现的机会少时，自旋的次数也会很少，CAS 的性能会很高；当并发修改的线程多，冲突出现的机会多时，自旋的次数也会很多，CAS 的性能会大大降低。所以，**提升 CAS 无**
**锁编程效率的关键在于减少冲突的机会**。

### 无锁编程实现轻量级安全自增

```java
public class Test {
    private int value;
    // 统计失败的次数
    private static final AtomicLong failure = new AtomicLong(0);

    public int increment() {
        return ++value;
    }

    // 自增
    public synchronized int synchronincrement() {
        return ++value;
    }

    // cas自增
    public int casincrement() {
        int expected = value;
        int newvalue = expected + 1;
        while (!compareAndSwap(expected, newvalue)) {
            expected = value;
            newvalue = expected + 1;
        }
        return newvalue;
    }

    private boolean compareAndSwap(int expected, int newvalue) {
        Unsafe unsafe = null;
        try {
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true);
            unsafe = (Unsafe) theUnsafe.get(null);

            long offset = unsafe.objectFieldOffset(Test.class.getDeclaredField("value"));
            System.out.println("offset:" + offset);
            boolean result = unsafe.compareAndSwapInt(this, offset, expected, newvalue);
            if (!result) {
                failure.incrementAndGet();
            }
            return result;
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }


    public static void main(String[] args) throws InterruptedException {
        Test obj = new Test();
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            Thread thread = new Thread(() -> {
                // 对value进行CAS操作
                for (int j = 0; j < 1000; j++) {
                    obj.casincrement();
                }
            });
            threads[i] = thread;
            thread.start();
        }
        // 等待所有线程执行完毕
        for (Thread thread : threads) {
            thread.join();
        }
        System.out.println(obj.value);
        System.out.println("失败次数：" + failure.get());
    }
}

// offset:12
// 10000
// 失败次数：49430
```

### 字段偏移量的计算

调用 Unsafe.objectFieldOffset(…)方法获取到的 Object 字段（也叫 Object 成员属性）的偏移量值是字段相 **对于 Object 头部的偏移**
**量，是一个相对的内存地址值，不是绝对的内存地址值**。

```java
public class Test {
    private int value;
    // 统计失败的次数
    private static final AtomicLong failure = new AtomicLong(0);
    // ...
}
```

虽然 Test 类有 2 个字段，但是其中有 1 个是静态字段，属于类的成员而不是对象的成员，真正属于对象的字段只有其中的 value 字段。所以类的对象结构
如图所示:

![](/resources/5976f102269041ed9c767096e9311971.png)

在 64 位的 JVM 堆区中一个 Test 对象的 Object Header（头部）占用了 12 字节，其中 Mark Word 占用了 8 字节（64 位），压缩过的 Class Pointer 占用了 4 字节。接在 Object Header 之后的就是成员属性 value 的内存区域 **，所以 value 属性相对于 Object Header 的偏移量为 12**。

## JUC 原子类

在多线程并发执行时，诸如“++”或“--”类的运算不具备原子性，不是线程安全的操作。通常情况下，大家会使用 synchronized 将这些线程不安全的操作变成同步操作，但是这样会降低并发程序的性能。所以，JDK 为这些类型不安全的操作提供了一些原子类，与 synchronized 同步机制相比，JDK 原子类是基于 CAS 轻量级原子操作的实现，使得程序运行效率变得更高。

### Atomic 原子操作包

Atomic 操作翻译成中文是指一个不可中断的操作，即使在多个线程一起执行 Atomic 类型操作的时候，一个操作一旦开始，就不会被其
他线程中断。所谓 Atomic 类，指的是具有原子操作特征的类。JUC 并发包中原子类的位置 JUC 并发包中的原子类都存放在 `java.util.concurrent.atomic` 类路径下.

根据操作的目标数据类型，可以将 JUC 包中的原子类分为 4 类：`基本原子类`、`数组原子类`、`原子引用类` 和 `字段更新原子类`。

### 基本原子类

- 基本原子类的功能是通过原子方式更新 Java 基础类型变量的值。
- 基本原子类主要包括以下三个：
  - `AtomicInteger`：整型原子类。
  - `AtomicLong`：长整型原子类。
  - `AtomicBoolean`：布尔型原子类。

### 数组原子类

- 数组原子类的功能是通过原子方式更数组中的某个元素的值。数
- 组原子类主要包括以下三个：
  - `AtomicIntegerArray`：整型数组原子类。
  - `AtomicLongArray`：长整型数组原子类。
  - `AtomicReferenceArray`：引用类型数组原子类。

### 引用原子类

- 引用原子类主要包括以下三个：
  - `AtomicReference`：引用类型原子类。
  - `AtomicMarkableReference`：带有更新标记位的原子引用类型。
  - `AtomicStampedReference`：带有更新版本号的原子引用类型。
- `AtomicMarkableReference` 类将 boolean 标记与引用关联起来，可以解决使用 AtomicBoolean 进行原子更新时可能出现的 ABA 问题。
- `AtomicStampedReference` 类将整数值与引用关联起来，可以解决使用 AtomicInteger 进行原子更新时可能出现的 ABA 问题。

### 字段更新原子类

- **字段更新** 原子类主要包括以下三个：
  - `AtomicIntegerFieldUpdater`：原子更新整型字段的更新器。
  - `AtomicLongFieldUpdater`：原子更新长整型字段的更新器。
  - `AtomicReferenceFieldUpdater`：原子更新引用类型中的字段

### 基础原子类 AtomicInteger

基础原子类 AtomicInteger 常用的方法如下：

```java
public final int get() //获取当前的值
public final int getAndSet(int newValue) //获取当前的值，然后设置新的值
public final int getAndIncrement() //获取当前的值，然后自增
public final int getAndDecrement() //获取当前的值，然后自减
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //通过CAS方式设置整数值
```

下面是一个基础原子类 AtomicInteger 的使用示例，具体代码如下：

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    // 定义一个 Atomic Integer 实例
    private static final AtomicInteger counter = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        // 创建并启动多个线程来更新计数器
        Thread thread1 = new Thread(() -> updateCounter(5));
        Thread thread2 = new Thread(() -> updateCounter(3));
        Thread thread3 = new Thread(() -> updateCounter(7));

        // 启动线程
        thread1.start();
        thread2.start();
        thread3.start();

        // 等待所有线程执行完毕
        thread1.join();
        thread2.join();
        thread3.join();

        System.out.println("Final counter value: " + counter.get());
    }

    private static void updateCounter(int increment) {
        for (int i = 0; i < increment; i++) {
            // 使用原子操作方法安全地增加计数值
            int newValue = counter.addAndGet(1);
            System.out.println(Thread.currentThread().getName() + " updated the counter to: " + newValue);
        }
    }
}
```

### 数组原子类 AtomicIntegerArray

AtomicIntegerArray.AtomicLongArray, AtomicReferenceArray 三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例来介绍。

AtomicIntegerArray 类的常用方法如下：

```java
//获取 index=i 位置元素的值
public final int get(int i)

//返回 index=i 位置当前的值，并将其设置为新值：newValue
public final int getAndSet(int i, int newValue)

//获取 index=i 位置元素的值，并让该位置的元素自增
public final int getAndIncrement(int i)

//获取 index=i 位置元素的值，并让该位置的元素自减
public final int getAndDecrement(int i)

//获取 index=i 位置元素的值，并加上预期的值
public final int getAndAdd(int delta)

//如果输入的数值等于预期值，就以原子方式将位置i的元素值设置为输入值（update）
boolean compareAndSet(int expect, int update)

//最终将位置i的元素设置为newValue
//lazySet()方法可能导致其他线程在之后的一小段时间内还是可以读到旧的值
public final void lazySet(int i, int newValue)下
```

```java
public void testAtomicIntegerArray() {
    int tempvalue = 0;
    // 原始的数组
    int[] array = {1, 2, 3, 4, 5, 6};

    // 包装为原子数组
    AtomicIntegerArray i = new AtomicIntegerArray(array);
    // 获取第0个元素，然后设置为2
    tempvalue = i.getAndSet(0, 2);
    // 输出tempvalue:1; i:[2, 2, 3, 4, 5, 6]
    Print.fo("tempvalue:" + tempvalue + "; i:" + i);
    // 获取第0个元素，然后自增
    tempvalue = i.getAndIncrement(0);
    // 输出tempvalue:2; i:[3, 2, 3, 4, 5, 6]
    Print.fo("tempvalue:" + tempvalue + "; i:" + i);

    // 获取第0个元素，然后增加一个delta 5
    tempvalue = i.getAndAdd(0, 5);
    // 输出tempvalue:3; i:[8, 2, 3, 4, 5, 6]
    Print.fo("tempvalue:" + tempvalue + "; i:" + i);
}
```

### AtomicInteger 线程安全原理

基础原子类（以 AtomicInteger 为例）**主要通过 CAS 自旋+volatile 的方案实现**，既保障了变量操作的线程安全性，又避免了 synchronized 重量级锁的高开销，使得 Java 程序的执行效率大为提升。

AtomicInteger 源码中的主要方法都是通过 CAS 自旋实现的。CAS 自旋的主要操作为：**如果一次 CAS 操作失败，获取最新的 value 值后，再**
**次进行 CAS 操作，直到成功**。

另外，AtomicInteger 所包装的内部 value 成员是一个使用关键字 volatile 修饰的内部成员。关键字 volatile 的原理比较复杂，简单地
说，该关键字可以保证任何线程在任何时刻总能拿到该变量的最新值，其目的在于保障变量值的线程可见性。

```java
public class AtomicInteger extends Number implements java.io.Serializable {

    // Unsafe类实例
    private static final Unsafe unsafe = Unsafe.getUnsafe();

    // 内部value值，使用volatile保证线程可见性
    private volatile int value;

    // value属性值的地址偏移量
    private static final long valueOffset;

    static {
        try {
            // 计算value 属性值的地址偏移量
            valueOffset = unsafe.objectFieldOffset(

                    AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) {
            throw new Error(ex);
        }
    }

    // 初始化
    public AtomicInteger(int initialValue) {
        value = initialValue;
    }

    // 获取当前value值
    public final int get() {
        return value;
    }

    // 方法：返回旧值并赋新值
    public final int getAndSet(int newValue) {
        for (; ; ) {// 自旋
            int current = get();// 获取旧值

            // 以CAS方式赋值，直到成功返回
            if (compareAndSet(current, newValue)) return current;
        }
    }

    // 方法：封装底层的CAS操作，对比expect(期望值)与value，若不同则返回false

    // 若expect与value相同，则将新值赋给value，并返回true
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    // 方法：安全自增 i++
    public final int getAndIncrement() {
        for (; ; ) { // 自旋
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next)) return current;
        }
    }

    // 方法：自定义增量数
    public final int getAndAdd(int delta) {
        for (; ; ) { // 自旋
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next)) return current;
        }
    }

    // 方法：类似++i，返回自增后的值
    public final int incrementAndGet() {
        for (; ; ) { // 自旋
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next)) return next;
        }
    }

    // 方法：返回加上delta后的值
    public final int addAndGet(int delta) {
        for (; ; ) { // 自旋
            int current = get();
            int next = current + delta;
            if (compareAndSet(current, next)) return next;
        }
    }
    // 省略其他源码
}
```

### 引用类型原子类

- 引用类型原子类包括以下种：
  - AtomicReference：基础的引用原子类。
  - AtomicStampedReference：带印戳的引用原子类。
  - AtomicMarkableReference：带修改标志的引用原子类。
- 上面三个类提供的方法几乎相同，所以这里以 AtomicReference 为例来介绍。

下面为大家介绍一个简单的 AtomicReference 类的使用示例

```java

qwen2.5:7b
在Java中，AtomicReference 是一个可以支持原子操作的类。它允许你以线程安全的方式更新对象的引用，而不必担心同步问题。这在多线程环境中非常有用。

下面是一个使用 AtomicReference 对 User 引用进行原子性修改的例子：

java


import java.util.concurrent.atomic.AtomicReference;

class User {
    private String name;
    // 其他属性和方法...

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class AtomicReferenceExample {

    public static void main(String[] args) {
        // 创建一个User对象
        User user = new User("John");

        // 使用AtomicReference包装user引用
        AtomicReference<User> atomicUserRef = new AtomicReference<>(user);

        // 第一个线程尝试更新用户的名字
        Thread thread1 = new Thread(() -> {
            try {
                Thread.sleep(500);  // 模拟一些延迟
                User newUser = new User("Jane");
                atomicUserRef.set(newUser);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // 第二个线程尝试读取用户的名字
        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(1000);  // 模拟一些延迟
                User readUser = atomicUserRef.get();
                System.out.println("Name after update: " + readUser.getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // 启动线程
        thread1.start();
        thread2.start();

        try {
            // 等待所有线程完成
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 属性更新原子类

此这里以 `AtomicIntegerFieldUpdater` 为例来介绍。使用属性更新原子类保障属性安全更新的流程大致需要两步：

1. 第一步，更新的对象属性必须使用 `public volatile` 修饰符。
2. 第二步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须调用静态方法 newUpdater()创建一个更新器，并且需要设
   置想要更新的类和属性。

下面为大家介绍一个简单的 AtomicIntegerFieldUpdater 类的使用示例，原子性地更新 User 对象的 age 属性，代码如下：

```java
public void testAtomicIntegerFieldUpdater() {
    // 调用静态方法newUpdater()创建一个更新器updater
    AtomicIntegerFieldUpdater<User> updater = AtomicIntegerFieldUpdater.newUpdater(User.class, "age");
    User user = new User("1", "张三");
    // 使用属性更新器的getAndIncrement、getAndAdd增加user的age值

    Print.tco(updater.getAndIncrement(user));// 1
    Print.tco(updater.getAndAdd(user, 100));// 101

    // 使用属性更新器的get获取user的age值
    Print.tco(updater.get(user));// 101
}
```

## ABA 问题

由于 CAS 原子操作性能高，因此其在 JUC 包中被广泛应用，只不过如果使用得不合理，CAS 原子操作就会存在 ABA 问题。

### 了解 ABA 问题

什么是 ABA 问题？举一个例子来说明。比如一个线程 A 从内存位置 M 中取出 V1，另一个线程 B 也取出 V1。现在假设线程 B 进行了一些操作之
后将 M 位置的数据 V1 变成了 V2，然后又在一些操作之后将 V2 变成了 V1。之后，线程 A 进行 CAS 操作，但是线程 A 发现 M 位置的数据仍然是 V1，然
后线程 A 操作成功。**尽管线程 A 的 CAS 操作成功，但是不代表这个过程是没有问题的，线程 A 操作的数据 V1 可能已经不是之前的 V1，而是被线程**
**B 替换过的 V1，这就是 ABA 问题**。

并发业务场景下, 两个并发的查询库存操作，同时从数据库都得到了库存是 5。用户 1 购买了 3 个库存，于是库存要设置为 2, 用户 2 购买了 2 个库存，于是库存要设置为 3, 这两个设置库存的接口并发执行，库存会先变成 2，再变成 3，导致数据不一致（实际卖出了 5 件商品，但库存只扣减了 2，最后一次设置库存会覆盖和掩盖前一次并发操作）

### ABA 问题解决方案

很多乐观锁的实现版本都是使用版本号（Version）方式来解决 ABA 问题。**乐观锁每次在执行数据的修改操作时都会带上一个版本号，版本号和数据的版本号一致就可以执行修改操作并对版本号执行加 1 操作，否则执行失败。** 因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加，不会减少。

### AtomicStampedReference

参考乐观锁的版本号，JDK 提供了一个 AtomicStampedReference 类来解决 ABA 问题。AtomicStampReference 在 CAS 的基础上增加了一个
Stamp（印戳或标记），使用这个印戳可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验。

AtomicStampReference 的 compareAndSet()方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预
期标志，如果全部相等，就以原子方式将引用值和印戳（Stamp）标志的值更新为给定的更新值。

```java
//构造器，V表示要引用的原始数据，initialStamp表示最初的版本印戳（版本号）
AtomicStampedReference(V initialRef, int initialStamp)

//获取被封装的数据
public V getRerference();

//获取被封装的数据的版本印戳
public int getStamp();


public boolean compareAndSet(
 V expectedReference, //预期引用值
 V newReference, //更新后的引用值
 int expectedStamp, //预期印戳（Stamp）标志值
 int newStamp) //更新后的印戳（Stamp）标志值
)
```

compareAndSet()方法的第一个参数是原来的 CAS 中的参数，第二个参数是替换后的新参数，第三个参数是原来 CAS 数据旧的版本号，第
四个参数表示替换后的新参数版本号。进行 CAS 操作时，若当前引用值等于预期引用值，并且当前印戳值等于预期印戳值，则以原子方式将引用值和印戳值更新为给定的更新值。
下面是一个简单的 AtomicStampedReference 使用示例:

```java
// 使用 AtomicStampedReference 存储当前的库存值和版本号
private static final AtomicStampedReference<Integer> stock = new AtomicStampedReference<>(10, 0);

private static void updateInventory(int quantity) {
        int currentValue, newStamp;
        do {
            currentValue = stock.getReference(); // 获取当前库存值
            newStamp = stock.getStamp() + 1; // 获取并增加版本号

            if (currentValue >= quantity) { // 检查是否足够库存
                int newValue = currentValue - quantity;
                boolean updated = stock.compareAndSet(currentValue, newValue, newStamp, newStamp + 1);
                if (!updated) {
                    System.out.println("Failed to update inventory in thread " + Thread.currentThread().getName());
                }
            } else {
                System.out.println("Insufficient stock for update by thread " + Thread.currentThread().getName());
            }
        } while (true); // 重试循环，直到更新成功
    }
```

### AtomicMarkableReference

AtomicMarkableReference 是 AtomicStampedReference 的简化版，**不关心修改过几次，只关心是否修改** 过。因此，其标记属性 mark 是 boolean 类型，而不是数字类型，标记属性 mark 仅记录值是否修改过。**AtomicMarkableReference 适用于只要知道对象是否被修改过，而不适用于对象被反复修改的场景**。

下面是一个简单的 AtomicMarkableReference 使用示例，通过两个线程分别更新同一个 stock 的值，第一个线程会更新成功，而第二个线程会更新失败，具体代码如下：

```java
// 使用 AtomicMarkableReference 存储当前的库存值和标记（表示是否有效）
private static final AtomicMarkableReference<Integer> stock = new AtomicMarkableReference<>(10, false);

private static void updateInventory(int quantity) {
        int currentValue, currentMark;

        do {
            // 获取当前的库存值和标记
            currentValue = stock.getReference();
            currentMark = stock.getMark();

            if (!currentMark && currentValue >= quantity) { // 检查是否足够库存且标记未被更改
                boolean updated = stock.compareAndSet(currentValue, currentValue - quantity, currentMark, true);
                if (updated) {
                    System.out.println("Inventory updated by thread " + Thread.currentThread().getName() + ": " + currentValue - quantity);
                } else {
                    System.out.println("Failed to update inventory in thread " + Thread.currentThread().getName());
                }
            } else {
                System.out.println("Insufficient stock for update by thread " + Thread.currentThread().getName());
            }
        } while (!updated); // 重试循环，直到更新成功
    }
```

## 提升高并发场景下 CAS 操作的性能

在争用激烈的场景下，会导致大量的 CAS 空自旋。比如，在大量线程同时并发修改一个 AtomicInteger 时，可能有很多线程会不停地自旋，甚至有的线程会进入一个无限重复的循环中。大量的 CAS 空自旋会浪费大量的 CPU 资源，大大降低了程序的性能。

![](/resources/7b62f86bfc36438d98c3f6d0ee146233.webp)

> **除了存在 CAS 空自旋之外，在 SMP 架构的 CPU 平台上，大量的 CAS 操作还可能导致“总线风暴”**

> 在高并发场景下如何提升 CAS 操作的性能呢？**可以使用 LongAdder 替代 AtomicInteger**。

### 以空间换时间：LongAdder

Java 8 提供了一个新的类 `LongAdder`，以空间换时间的方式提升高并发场景下 CAS 操作的性能。LongAdder 的核心思想是热点分离，与 ConcurrentHashMap 的设计思想类似 **：将 value 值分离成一个数组，当多线程访问时，通过 Hash 算法将线程映射到数组的一个元素进行操作；而获取最终的 value 结果时，则将数组的元素求和**。最终，通过 LongAdder 将内部操作对象 **从单个 value 值“演变”成一系列的数组元素，从而减小了内部竞争的粒度。**

```java

public class AtomicLongAdderTest {
    public static void main(String[] args) throws Exception{
        testAtomicLongAdder(1, 10000000);
        testAtomicLongAdder(10, 10000000);
        testAtomicLongAdder(100, 10000000);
    }

    static void testAtomicLongAdder(int threadCount, int times) throws Exception{
        System.out.println("threadCount: " + threadCount + ", times: " + times);
        long start = System.currentTimeMillis();
        testLongAdder(threadCount, times);
        System.out.println("LongAdder 耗时：" + (System.currentTimeMillis() - start) + "ms");
        System.out.println("threadCount: " + threadCount + ", times: " + times);
        long atomicStart = System.currentTimeMillis();
        testAtomicLong(threadCount, times);
        System.out.println("AtomicLong 耗时：" + (System.currentTimeMillis() - atomicStart) + "ms");
        System.out.println("----------------------------------------");
    }

    static void testAtomicLong(int threadCount, int times) throws Exception{
        AtomicLong atomicLong = new AtomicLong();
        List<Thread> list = new ArrayList();
        for (int i = 0; i < threadCount; i++) {
            list.add(new Thread(() -> {
                for (int j = 0; j < times; j++) {
                    atomicLong.incrementAndGet();
                }
            }));
        }

        for (Thread thread : list) {
            thread.start();
        }

        for (Thread thread : list) {
            thread.join();
        }

        System.out.println("AtomicLong value is : " + atomicLong.get());
    }

    static void testLongAdder(int threadCount, int times) throws Exception{
        LongAdder longAdder = new LongAdder();
        List<Thread> list = new ArrayList();
        for (int i = 0; i < threadCount; i++) {
            list.add(new Thread(() -> {
                for (int j = 0; j < times; j++) {
                    longAdder.increment();
                }
            }));
        }

        for (Thread thread : list) {
            thread.start();
        }

        for (Thread thread : list) {
            thread.join();
        }

        System.out.println("LongAdder value is : " + longAdder.longValue());
    }
}


threadCount: 1, times: 10000000
LongAdder value is : 10000000
LongAdder 耗时：75ms
threadCount: 1, times: 10000000
AtomicLong value is : 10000000
AtomicLong 耗时：23ms
----------------------------------------
threadCount: 10, times: 10000000
LongAdder value is : 100000000
LongAdder 耗时：52ms
threadCount: 10, times: 10000000
AtomicLong value is : 100000000
AtomicLong 耗时：958ms
----------------------------------------
threadCount: 100, times: 10000000
LongAdder value is : 1000000000
LongAdder 耗时：266ms
threadCount: 100, times: 10000000
AtomicLong value is : 1000000000
AtomicLong 耗时：12221ms
----------------------------------------
```

这里可以看到 **随着并发的增加**，`AtomicLong` 性能是急剧下降的，耗时是 `LongAdder` 的数倍。至于原因我们还是接着往后看。

### AtomicLong 可以弃用了吗？

看上去 `LongAdder` 的性能全面超越了 `AtomicLong`，而且阿里巴巴开发手册也提及到 **推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观
锁的重试次数）**，但是我们真的就可以舍弃掉 `LongAdder` 了吗？

当然不是，我们需要看场景来使用，如果是并发不太高的系统，使用 `AtomicLong` 可能会更好一些，而且内存需求也会小一些。

我们通过分析源码 `sum()` 方法后可以知道 `LongAdder` 在统计的时候如果有并发更新，可能导致统计的数据有误差。而在 **高并发统计计数** 的场景下，才更适合使用 `LongAdder`。

## LongAdder 的原理

### 操作原理图

先看下 `LongAdder` 的操作原理图：

![](/resources/70e8842b2ff142f6863d71780727074a.webp)

既然说到 `LongAdder` 可以显著提升高并发环境下的性能，那么它是如何做到的？

### 分段加锁思路

> **设计思想上，`LongAdder` 采用 "分段" 的方式降低 `CAS` 失败的频次**

我们知道，`AtomicLong` 中有个内部变量 `value` 保存着实际的 `long` 值，所有的操作都是针对该变量进行。也就是说，高并发环境下，`value` 变量其实是一个 **热点数据**，也就是 **N 个线程竞争一个热点。**

`LongAdder` 的基本思路就是 **分散热点**，将 `value` 值的新增操作分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个 `value` 值进行 `CAS` 操作，这样热点就被分散了，冲突的概率就小很多。

`LongAdder` 有一个全局变量 `volatile long base` 值，当并发不高的情况下都是通过 `CAS` 来直接操作 `base` 值，如果 `CAS` 失败，则针对 `LongAdder` 中的 `Cell[]` 数组中的 `Cell` 进行 `CA` S 操作，减少失败的概率。

例如当前类中 `base = 10`，有三个线程进行 `CAS` 原子性的 **+1 操作**，**线程一执行成功，此时 base = 11**，**线程二、线程三执行失败后** 开始针对于 `Cell[]` 数组中的 `Cell` 元素进行 **+1 操作**，同样也是 `CAS` 操作，此时数组 `index=1` 和 `index=2` 中 `Cell` 的 `value` 都被设置为了 1.

执行完成后，统计累加数据：`sum = 11 + 1 + 1 = 13`，利用 `LongAdder` 进行累加的操作就执行完了，流程图如下：

![img](/resources/5a11904da2c54c17b3375dbb750b2c11.webp)

如果要获取真正的 `long` 值，只要将各个槽中的变量值累加返回。这种分段的做法类似于 `JDK7` 中 `ConcurrentHashMap` 的分段锁。

### 消除伪共享

在 `LongAdder` 的父类 `Striped64` 中存在一个 `volatile Cell[] cells;` 数组，其长度是 **2 的幂次方**，每个 `Cell` 都使用 `@Contended` 注解进行修饰，而 `@Contended` 注解可以进行 **缓存行填充**，从而解决 **伪共享问题**。伪共享会导致缓存行失效，缓存一致性开销变大。

```java
@sun.misc.Contended static final class Cell {

}
```

**伪共享** 指的是多个线程同时读写同一个缓存行的不同变量时导致的 `CPU缓存失效`。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。这里对于伪共享我只是提一下概念，并不会深入去讲解，大家可以自行查阅一些资料。

解决伪共享的方法一般都是使用 **直接填充**，我们只需要保证不同线程的变量存在于不同的 `CacheLine` 即可，使用多余的字节来填充可以做点这一点，这样就不会出现伪共享问题。

![缓存行填充代码](/resources/fb5a84f139c644d79a6bd0fcd50d5c47.webp)

![缓存行填充](/resources/d64b3f0aef6b45a0bfe3943f710345a8.webp)

在 `Striped64` 类中我们可以看看 `Doug Lea` 在 `Cell` 上加的注释也有说明这一点：

![Cell 注释](/resources/2a6bc3028d584123889adda327043a96.webp)

> 红框中的翻译如下：

`Cell` 类是 `AtomicLong` 添加了 `padded（via@sun.misc.compended)` 来消除 **伪共享** 的变种版本。缓存行填充对于大多数原子来说是繁琐的，因为它们通常不规则地分散在内存中，因此彼此之间不会有太大的干扰。但是，驻留在数组中的原子对象往往彼此相邻，因此在没有这种预防措施的情况下，通常会共享缓存行数据（对性能有巨大的负面影响）。

### 惰性求值

`LongAdder` 只有在使用 `longValue()` 获取当前累加值时才会真正的去结算计数的数据，`longValue()` 方法底层就是调用 `sum()` 方法，对 `base` 和 `Cell数组` 的数据累加然后返回，做到数据写入和读取分离。

而 `AtomicLong` 使用 `incrementAndGet()` 每次都会返回 `long` 类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。

### LongAdder 实现原理

之前说了，`AtomicLong` 是多个线程针对单个 **热点值 value 进行原子操作**。而 `LongAdder` 是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行 `CAS操作`。

比如有三个线程同时对 value 增加 1，那么 value = 1 + 1 + 1 = 3

但是对于 LongAdder 来说，内部有一个 base 变量，一个 Cell \[] 数组。

- base 变量：非竞态条件下，直接累加到该变量上
- Cell \[] 数组：竞态条件下，累加个各个线程自己的槽 Cell \[i] 中
- 最终结果的计算是下面这个形式：![](/resources/c02fc9668ff1438e82113caee1ee08b3.png)

## LongAdder 源码剖析

前面已经用图分析了 `LongAdder` 高性能的原理，我们继续看下 `LongAdder` 实现的源码：

### `add()` 方法

```java
public class LongAdder extends Striped64 implements Serializable {
    public void increment() {
        add(1L);
    }

    public void add(long x) {
        Cell[] as; long b, v; int m; Cell a;
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[getProbe() & m]) == null ||
                !(uncontended = a.cas(v = a.value, v + x)))
                longAccumulate(x, null, uncontended);
        }
    }

    final boolean casBase(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
    }
}
```

一般我们进行计数时都会使用 `increment()` 方法，每次进行 **+1 操作**，`increment()` 会直接调用 `add()` 方法。

**变量说明：**

- as 表示 cells 引用
- b 表示获取的 base 值
- v 表示 期望值,
- m 表示 cells 数组的长度
- a 表示当前线程命中的 cell 单元格

> **条件一：as == null || (m = as.length - 1) < 0**
> 此条件成立说明 cells 数组未初始化。如果不成立则说明 cells 数组已经完成初始化，对应的线程需要找到 Cell 数组中的元素去写值。

![条件一](/resources/7213ceabaa7e4e1bb5df93a8b834b783.webp)

> **条件二：(a = as \[getProbe() & m]) == null**

getProbe()获取当前线程的 hash 值，m 表示 cells 长度-1，cells 长度是 2 的幂次方数，原因之前也讲到过，与数组长度取模可以转化为按位与运算，提升计算性能。

当条件成立时说明当前线程通过 hash 计算出来数组位置处的 cell 为空，进一步去执行 longAccumulate()方法。如果不成立则说明对应的 cell 不为空，下一步将要将 x 值通过 CAS 操作添加到 cell 中。

> **条件三：!(uncontended = a.cas(v = a.value, v + x)**

主要看 a.cas(v = a.value, v + x)，接着条件二，说明当前线程 hash 与数组长度取模计算出的位置的 cell 有值，此时直接尝试一次 CAS 操作，如果成功则退出 if 条件，失败则继续往下执行 longAccumulate()方法。

![条件二/条件三](/resources/6e1fc112fa9844f7af3ece31db70d8a4.webp)

### longAccumulate()方法

接着往下看核心的 `longAccumulate()` 方法，代码很长，后面会一步步分析，先上代码：`java.util.concurrent.atomic.Striped64.`:

```java
final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) {
    int h;
    if ((h = getProbe()) == 0) {
        ThreadLocalRandom.current();
        h = getProbe();
        wasUncontended = true;
    }
    boolean collide = false;
    for (;;) {
        Cell[] as; Cell a; int n; long v;
        if ((as = cells) != null && (n = as.length) > 0) {
            if ((a = as[(n - 1) & h]) == null) {
                if (cellsBusy == 0) {
                    Cell r = new Cell(x);
                    if (cellsBusy == 0 && casCellsBusy()) {
                        boolean created = false;
                        try {
                            Cell[] rs; int m, j;
                            if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)
                wasUncontended = true;
            else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
                break;
            else if (n >= NCPU || cells != as)
                collide = false;
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 && casCellsBusy()) {
                try {
                    if (cells == as) {
                        Cell[] rs = new Cell[n << 1];
                        for (int i = 0; i < n; ++i)
                            rs[i] = as[i];
                        cells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;
            }
            h = advanceProbe(h);
        }
        else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
            boolean init = false;
            try {
                if (cells == as) {
                    Cell[] rs = new Cell[2];
                    rs[h & 1] = new Cell(x);
                    cells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
            break;
    }
}
```

代码很长，`if else` 分支很多，除此看肯定会很头疼。这里一点点分析，然后结合画图一步步了解其中实现原理。

**我们首先要清楚执行这个方法的前置条件，它们是或的关系，如上面条件一、二、三**

1. cells 数组没有初始化
2. cells 数组已经初始化，但是当前线程对应的 cell 数据为空
3. cells 数组已经初始化， 当前线程对应的 cell 数据为空，且 CAS 操作+1 失败

**longAccumulate()方法的入参：**

- long x 需要增加的值，一般默认都是 1
- LongBinaryOperator fn 默认传递的是 null
- wasUncontended 竞争标识，如果是 false 则代表有竞争。只有 cells 初始化之后，并且当前线程 CAS 竞争修改失败，才会是 false

**然后再看下 Striped64 中一些变量或者方法的定义：**

- base: 类似于 AtomicLong 中全局的 value 值。在没有竞争情况下数据直接累加到 base 上，或者 cells 扩容时，也需要将数据写入到 base 上
- collide：表示扩容意向，false 一定不会扩容，true 可能会扩容。
- cellsBusy：初始化 cells 或者扩容 cells 需要获取锁, 0: 表示无锁状态 1: 表示其他线程已经持有了锁
- casCellsBusy(): 通过 CAS 操作修改 cellsBusy 的值，CAS 成功代表获取锁，返回 true
- NCPU：当前计算机 CPU 数量，Cell 数组扩容时会使用到
- getProbe(): 获取当前线程的 hash 值
- advanceProbe(): 重置当前线程的 hash 值

**接着开始正式解析 longAccumulate()源码：**

#### 获取当前线程的 hash 值

```java
private static final long PROBE;

if ((h = getProbe()) == 0) {
    ThreadLocalRandom.current();
    h = getProbe();
    wasUncontended = true;
}

static final int getProbe() {
    return UNSAFE.getInt(Thread.currentThread(), PROBE);
}
```

我们上面说过 `getProbe()` 方法是为了获取当前线程的 `hash值`，具体实现是通过 `UNSAFE.getInt()` 实现的，`PROBE` 是在初始化时候获取当前线程 `threadLocalRandomProbe` 的值。

> 注：Unsafe.getInt()有三个重载方法 getInt(Object o, long offset)、getInt(long address) 和 getIntVolatile(long address)，都是从指定的位置获取变量的值，只不过第一个的 offset 是相对于对象 o 的相对偏移量，第二个 address 是绝对地址偏移量。如果第一个方法中 o 为 null 是，offset 也会被作为绝对偏移量。第三个则是带有 volatile 语义的 load 读操作。

如果当前线程的 **hash 值 h = getProbe()为 0，0 与任何数取模都是 0，会固定到数组第一个位置**，所以这里做了优化，使用 `ThreadLocalRandom` 为当前线程重新计算一个 `hash` 值。最后设置 `wasUncontended = true`，这里含义是重新计算了当前线程的 `hash` 后认为此次不算是一次竞争。`hash` 值被重置就好比一个全新的线程一样，所以设置了竞争状态为 `true`。

可以画图理解为：

![wasUncontended 设置说明](/resources/9924c3f78db443cab26f855045129e6b.webp)

接着执行 `for循环`，我们可以把 `for循环` 代码拆分一下，每个 `if条件` 算作一个 `CASE` 来分析：

```java
final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) {

    for (;;) {
        Cell[] as; Cell a; int n; long v;
        if ((as = cells) != null && (n = as.length) > 0) {

        }
        else if (cellsBusy == 0 && cells == as && casCellsBusy()) {

        }
        else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x))))

    }
}
```

如上所示，第一个 `if语句代表CASE1`，里面再有 `if判断` 会以 `CASE1.1` 这种形式来讲解，下面接着的 `else if` 为 `CASE2`， 最后一个为 `CASE3`

#### CASE1 执行条件

```java
if ((as = cells) != null && (n = as.length) > 0) {

}
```

`cells数组` 不为空，且数组长度大于 0 的情况会执行 `CASE1`，`CASE1` 的实现细节代码较多，放到最后面讲解。

#### CASE2 执行条件和实现原理

```java
else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
    boolean init = false;
        try {
            if (cells == as) {
                Cell[] rs = new Cell[2];
                rs[h & 1] = new Cell(x);
                cells = rs;
                init = true;
            }
        } finally {
            cellsBusy = 0;
        }
        if (init)
            break;
}
```

`CASE2` 标识 `cells数组` 还未初始化，因为判断 `cells == as`，这个代表当前线程到了这里获取的 `cells` 还是之前的一致。我们可以先看这个 `case`，最后再回头看最为麻烦的 `CASE1` 实现逻辑。

`cellsBusy` 上面说了是加锁的状态，初始化 `cells数组` 和扩容的时候都要获取加锁的状态，这个是通过 `CAS` 来实现的，为 0 代表无锁状态，为 1 代表其他线程已经持有锁了。`cells==as` 代表当前线程持有的数组未进行修改过，`casCellsBusy()` 通过 `CAS操作` 去获取锁。但是里面的 `if条件` 又再次判断了 `cell==as`，这一点是不是很奇怪？通过画图来说明下问题：

![cells == as 双重判断说明](/resources/81a35488a19a42d6954fb1369d46990a.webp)

如果上面条件都执行成功就会执行数组的初始化及赋值操作， `Cell[] rs = new Cell[2]` 表示数组的长度为 2，`rs[h & 1] = new Cell(x)` 表示创建一个新的 `Cell元素`，**value 是 x 值，默认为 1。**

`h & 1` 类似于我们之前 `HashMap` 或者 `ThreadLocal` 里面经常用到的计算散列桶 `index` 的算法，通常都是 `hash & (table.len - 1)`，这里就不做过多解释了。 执行完成后直接退出 `for循环`。

#### CASE3 执行条件和实现原理

```java
else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
    break;
```

进入到这里说明 `cells` 正在或者已经初始化过了，执行 `caseBase()` 方法，通过 `CAS操作` 来修改 `base` 的值，如果修改成功则跳出循环，这个 `CAS` E 只有在初始化 `Cell数组` 的时候，多个线程尝试 `CAS` 修改 `cellsBusy` 加锁的时候，失败的线程会走到这个分支，然后直接 `CAS` 修改 `base` 数据。

#### CASE1 实现原理

分析完了 `CASE2和CASE3`，我们再折头回看一下 `CASE1`，进入 `CASE1` 的前提是：`cells数组` 不为空，已经完成了初始化赋值操作。

接着还是一点点往下拆分代码，首先看第一个判断分支 `CASE1.1`：

```java
if ((a = as[(n - 1) & h]) == null) {
    if (cellsBusy == 0) {
        Cell r = new Cell(x);
        if (cellsBusy == 0 && casCellsBusy()) {
            boolean created = false;
            try {
                Cell[] rs; int m, j;
                if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {
                    rs[j] = r;
                    created = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (created)
                break;
            continue;
        }
    }
    collide = false;
}
```

这个 if 条件中 `(a = as[(n - 1) & h]) == null` 代表当前线程对应的数组下标位置的 `cell` 数据为 `null`，代表没有线程在此处创建 `Cell` 对象。

接着判断 `cellsBusy==0`，代表当前锁未被占用。然后新创建 `Cell对象`，接着又判断了一遍 `cellsBusy == 0`，然后执行 `casCellsBusy()` 尝试通过 CAS 操作修改 `cellsBusy=1`，加锁成功后修改扩容意向 `collide = false;`

```java
for (;;) {
    if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {
        rs[j] = r;
        created = true;
    }

    if (created)
        break;
    continue;
}
```

上面代码判断当前线程 `hash` 后指向的数据位置元素是否为空，如果为空则将 `cell` 数据放入数组中，跳出循环。如果不为空则继续循环。

![CASE1.1](/resources/e8ad62b7fd8d42348a8a092e2152c3e5.webp)

继续往下看代码，**CASE1.2**：

```java
else if (!wasUncontended)
    wasUncontended = true;

h = advanceProbe(h);
```

`wasUncontended` 表示 `cells` 初始化后，当前线程竞争修改失败 `wasUncontended =false`，这里只是重新设置了这个值为 `true`，紧接着执行 `advanceProbe(h)` 重置当前线程的 `hash`，重新循环。

接着看 **CASE1.3**：

```java
else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
    break;
```

进入 `CASE1.3` 说明当前线程对应的数组中有了数据，也重置过 `hash值`，这时通过 CAS 操作尝试对当前数中的 `value值` 进行累加 x 操作，x 默认为 1，如果 `CAS` 成功则直接跳出循环。

![](/resources/c5cc55dc6d704de3a2c725487eb7c160.webp)

接着看 **CASE1.4：**

```java
else if (n >= NCPU || cells != as)
    collide = false;
```

如果 `cells数组` 的长度达到了 `CPU核心数`，或者 `cells` 扩容了，设置扩容意向 `collide为false` 并通过下面的 `h = advanceProbe(h)` 方法修改线程的 `probe` 再重新尝试

至于这里为什么要提出和 `CPU数量` 做判断的问题：每个线程会通过线程对 `cells[threadHash%cells.length]` 位置的 `Cell` 对象中的 `value` 做累加，这样相当于将线程绑定到了 `cells` 中的某个 `cell` 对象上，如果超过 `CPU数量` 的时候就不再扩容是因为 `CPU` 的数量代表了机器处理能力，当超过 `CPU` 数量时，多出来的 `cells` 数组元素没有太大作用。

![多线程更新 Cell](/resources/35837aabf837477192dba5cffffd936c.webp)

接着看 **CASE1.5**：

```java
 else if (!collide)
   collide = true;
```

如果扩容意向 `collide` 是 `false` 则修改它为 `true`，然后重新计算当前线程的 `hash` 值继续循环，在 `CASE1.4` 中，如果当前数组的长度已经大于了 `CPU` 的核数，就会再次设置扩容意向 `collide=false`，这里的意义是保证扩容意向为 `false` 后不再继续往后执行 `CASE1.6` 的扩容操作。

**接着看 CASE1.6 分支：**

```java
else if (cellsBusy == 0 && casCellsBusy()) {
    try {
        if (cells == as) {
            Cell[] rs = new Cell[n << 1];
            for (int i = 0; i < n; ++i)
                rs[i] = as[i];
            cells = rs;
        }
    } finally {
        cellsBusy = 0;
    }
    collide = false;
    continue;
}
```

这里面执行的其实是扩容逻辑，首先是判断通过 `CAS` 改变 `cellsBusy` 来尝试加锁，如果 `CAS` 成功则代表获取锁成功，继续向下执行，判断当前的 `cells` 数组和最先赋值的 `as` 是同一个，代表没有被其他线程扩容过，然后进行扩容，扩容大小为之前的容量的两倍，这里用的按位左移 1 位来操作的。

```java
Cell[] rs = new Cell[n << 1];
```

扩容后再将之前数组的元素拷贝到新数组中，释放锁设置 `cellsBusy = 0`，设置扩容状态，然后继续循环执行。

到了这里，我们已经分析完了 `longAccumulate()` 所有的逻辑，逻辑分支挺多，仔细分析看看其实还是挺清晰的，流程图如下：

### 流程图

![流程图](/resources/567302a6c3f144d9a0302a3e467e87d3.webp)

我们再举一些线程执行的例子里面场景覆盖不全，大家可以按照这种模式自己模拟场景分析代码流程：

![多线程执行示例](/resources/1b8166d790484c53aa4a3c960a0e31e4.webp)

如有问题也请及时指出，我会第一时间更正，不胜感激！

### LongAdder 的 sum 方法

当我们最终获取计数器值时，我们可以使用 `LongAdder.longValue()` 方法，其内部就是使用 `sum` 方法来汇总数据的。

`java.util.concurrent.atomic.LongAdder.sum()`:

```java
public long sum() {
    Cell[] as = cells; Cell a;
    long sum = base;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
```

实现很简单，base + 遍历 `cells` 数组中的值，然后累加。

## CAS 在 JDK 中的广泛应用

### CAS 操作的弊端和规避措施

CAS 操作的弊端主要有以下三点：

1. ABA 问题
   - 使用 CAS 操作内存数据时，数据发生过变化也能更新成功，如操作序列 A ==> B== > A 时，最后一个 CAS 的预期数据 A 实际已经发生过更改，但也能更新成功，这就产生了 ABA 问题。
   - ABA 问题的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候将版本号加 1，那么操作序列 A ==> B== > A 就会变成 A1 ==> B2== > A3，如果将 A1 当作 A3 的预期数据，就会操作失败。
   - JDK 提供了两个类 `AtomicStampedReference` 和 `AtomicMarkableReference` 来解决 ABA 问题。比较常用的是 AtomicStampedReference 类，该类的 compareAndSet()方法的作用是首先检查当前引用是否等于预期引用，以及当前印戳是否等于预期印戳，如果全部相等，就以原子方式将引用和印戳的值一同设置为新的值。
2. 只能保证一个共享变量之间的原子性操作
   - 当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，CAS 就无法保证操作的原子
     性。
   - 一个比较简单的规避方法为：把多个共享变量合并成一个共享变量来操作。
   - JDK 提供了 `AtomicReference` 类来保证引用对象之间的原子性，可以把多个变量放在一个 AtomicReference 实例后再进行 CAS 操作。比如有两个共享变量 i ＝ 1、j = 2，可以将二者合并成一个对象，然后用 CAS 来操作该合并对象的 AtomicReference 引用。
3. 开销问题自旋 CAS 如果长时间不成功（不成功就一直循环执行，直到成功），就会给 CPU 带来非常大的执行开销。**解决 CAS 恶性空自旋的有效方式之一是以空间换时间**，较为常见的方案为：
   - 分散操作热点，使用 LongAdder 替代基础原子类 AtomicLong，LongAdder 将单个 CAS 热点（value 值）分散到一个 cells 数组中。
   - 使用队列削峰，将发生 CAS 争用的线程加入一个队列中排队，降低 CAS 争用的激烈程度。JUC 中非常重要的基础类 AQS（抽象队列同步器）就是这么做的。

### CAS 操作在 JDK 中的应用

- CAS 在 java.util.concurrent.atomic 包中的原子类、Java AQS 以及显式锁、CurrentHashMap 等重要并发容器类的实现都有非常广泛的应用。
- 在 java.util.concurrent.atomic 包的原子类（如 AtomicXXX）中都使用了 CAS 来保障对数字成员进行操作的原子性。
- java.util.concurrent 的大多数类（包括显式锁、并发容器）都是基于 AQS 和 AtomicXXX 来实现的，其中 AQS 通过 CAS 保障它内部双向队列头部、尾部操作的原子性。

## 参考

[longadder 原理 - r1-12king - 博客园](https://www.cnblogs.com/r1-12king/p/17406220.html)
