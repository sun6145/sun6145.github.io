---
layout: post
title: 线程池原理与实战
abbrlink: 152eccf92187436495f0e3650e08ef7a
tags:
  - juc
categories:
  - JDK
  - 多线程编程
date: 1745339269746
updated: 1746417742613
---

文章介绍了线程池的一系列关键概念和一些常用的工具类方法和建议，这些可以帮助开发者更加方便地管理和优化他们的线程池配置。

<!--more-->

***

## 前言

- Java 线程的创建非常昂贵，需要 JVM 和 OS（操作系统）配合完成大量的工作：
  - 必须为线程堆栈分配和初始化大量内存块，其中包含至少 1MB 的栈内存。
  - 需要进行系统调用，以便在 OS（操作系统）中创建和注册本地线程。
- Java 高并发应用频繁创建和销毁线程的操作是非常低效的，而且是不被编程规范所允许的。**如何降低 Java 线程的创建成本？必须使用到线程池**。线程池主要解决了以下两个问题：
  - 提升性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。
  - 线程管理：每个 Java 线程池会保持一些基本的线程统计信息，例如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到的异步任务进行高效调度。

## JUC 的线程池架构

JUC 就是 java.util.concurrent 工具包的简称，该工具包是从 JDK 1.5 开始加入 JDK 的，是用于完成高并发、处理多线程的一个工具包。

![](/resources/583a3ce149f24b8ea06b3c6b5bb278f2.png)

### Executor

Executor 是 Java 异步目标任务的“执行者”接口，其目标是执行目标任务。“执行者”Executor 提供了 execute()接口来执行已提交的 Runnable 执行目标实例。Executor 作为执行者的角色，其目的是提供一种将“任务提交者”与“任务执行者”分离开来的机制。它只包含一个函数式方法：

```java
 void execute(Runnable command);
```

### ExecutorService

ExecutorService 继承于 Executor。它是 Java 异步目标任务的“执行者服务接”口，对外提供异步任务的接收服务。ExecutorService 提供了“接收异步任务并转交给执行者”的方法，如 submit 系列方法、invoke 系列方法等，具体如下：

```java
//向线程池提交单个异步任务
<T> Future<T> submit(Callable<T> task);
//向线程池提交批量异步任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
```

### AbstractExecutorService

AbstractExecutorService 是一个抽象类，它实现了 ExecutorService 接口。AbstractExecutorService 存在的目的是为 ExecutorService 中的接口提供默认实现。

### ThreadPoolExecutor

ThreadPoolExecutor 就是大名鼎鼎的“线程池”实现类，它继承于 AbstractExecutorService 抽象类。

ThreadPoolExecutor 是 JUC 线程池的核心实现类。线程的创建和终止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的数据统计，方便线程的管理和监控。

### ScheduledExecutorService

ScheduledExecutorService 是一个接口，它继承于 ExecutorService。它是一个可以完成“延时”和“周期性”任务的调度线程池接口，其功能和 Timer/TimerTask 类似。

### ScheduledThreadPoolExecutor

ScheduledThreadPoolExecutor 继承于 ThreadPoolExecutor，它提供了 ScheduledExecutorService 线程池接口中“延时执行”和“周期执行”等抽象调度方法的具体实现。

ScheduledThreadPoolExecutor 类似于 Timer，但是在高并发程序中，**ScheduledThreadPoolExecutor 的性能要优于 Timer**。

### Executors

Executors 是一个静态工厂类，它通过静态工厂方法返回 ExecutorService、ScheduledExecutorService 等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。

## Executors 快捷创建线程池

尽管 Executors 的工厂方法使用方便，但是在生产场景中被很多企业（尤其是大厂）的开发规范所禁用。

### newSingleThreadExecutor

该方法用于创建一个“单线程化线程池”，也就是只有一个线程的线程池，所创建的线程池用唯一的工作线程来执行任务，使用此方法创建的线程池能保证所有任务按照指定顺序（如 FIFO）执行。

调用 `Executors.newSingleThreadExecutor()` 快捷工厂方法创建一个“单线程化线程池”的测试用例，其代码如下：

```java
// 测试用例：只有一个线程的线程池
public void testSingleThreadExecutor() {
    ExecutorService pool = Executors.newSingleThreadExecutor();
    for (int i = 0; i < 5; i++) {
        pool.execute(new TargetTask());
        pool.submit(new TargetTask());
    }
    sleepSeconds(1000);
 // 关闭线程池
    pool.shutdown();
}
```

该线程池有以下特点：

1. 单线程化的线程池中的任务是按照提交的次序顺序执行的。
2. 池中的唯一线程的存活时间是无限的。
3. 当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是无界的。

总体来说，单线程化的线程池所适用的场景是：

1. 任务按照提交次序，一个任务一个任务地逐个执行的场景。

2. 以上用例在最后调用 shutdown()方法来关闭线程池。执行 shutdown()方法后，线程池状态变为 SHUTDOWN，此时线程池将拒绝新任务，不能再往线程池中添加新任务，否则会抛出 RejectedExecutionException 异常。此时，线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成才会退出。还有一个与 shutdown()类似的方法，叫作 shutdownNow()，执行 shutdownNow()方法后，线程池状态会立刻变成 STOP，并试图停止所有正在执行的线程，并且不再处理还在阻塞队列中等待的任务，会返回那些未执行的任务。

### newFixedThreadPool

该方法用于创建一个“固定数量的线程池”，其唯一的参数用于设置池中线程的“固定数量”。调用 Executors.newFixedThreadPool(int threads)快捷工厂方法创建“固
定数量的线程池”

“固定数量的线程池”的特点大致如下：

1. 如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量。
2. 线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
3. 在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）。

“固定数量的线程池”的适用场景：需要任务长期执行的场景。“固定数量的线程池”的线程数能够比较稳定地保证一个数，能够避免频繁回收线程和创建线程，故适用于处理 CPU 密集型的任务，在 CPU 被工作线程长时间占用的情况下，能确保尽可能少地分配线程。

“固定数量的线程池”的弊端：内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽。

### newCachedThreadPool

该方法用于创建一个“可缓存线程池”，如果线程池内的某些线程无事可干成为空闲线程，“可缓存线程池”可灵活回收这些空闲线程。

“可缓存线程池”的特点大致如下：

1. 在接收新的异步任务 target 执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务。
2. 此线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。
3. 如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60 秒不执行任务）线程。
   “

可缓存线程池”的适用场景：

1. 需要快速处理突发性强、耗时较短的任务场景，如 Netty 的 NIO 处理场景、REST API 接口的瞬时削峰场景。
2. “可缓存线程池”的线程数量不固定，只要有空闲线程就会被回收；接收到的新异步任务执行目标，查看是否有线程处于空闲状态，如果没有就直接创建新的线程。

“可缓存线程池”的弊端：线程池没有最大线程数量限制，如果大量的异步任务执行目标实例同时提交，可能会因创建线程过多而导致资源耗尽。

### newScheduledThreadPool

该方法用于创建一个“可调度线程池”，即一个提供“延时”和“周期性”任务调度功能的 ScheduledExecutorService 类型的线程池。ScheduleExecutorService 接口中有多个重要的接收被调目标任务的方法，其中 `scheduleAtFixedRate` 和 `scheduleWithFixedDelay` 使用得比较多。

```java
//方法一：创建一个可调度线程池，池内仅含有一个线程
 public static ScheduledExecutorService newSingleThreadScheduledExecutor();

 //方法二：创建一个可调度线程池，池内含有N个线程，N的值为输入参数corePoolSize
 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) ;

scheduled.scheduleAtFixedRate(new TargetTask(), 0, 500, TimeUnit.MILLISECONDS);
 // 以上参数中：0表示首次执行任务的延迟时间，500表示每次执行任务的间隔时间
 // TimeUnit.MILLISECONDS是执行的时间间隔数值，单位为毫秒


public ScheduledFuture<?> scheduleAtFixedRate(
     Runnable command, //异步任务target执行目标实例
     long initialDelay, //首次执行延时
     long period, //两次开始执行最小间隔时间
     TimeUnit unit //所设置的时间的计时单位，如TimeUnit.SECONDS常量
 );

public ScheduledFuture<?> scheduleWithFixedDelay(
     Runnable command, //异步任务target执行目标实例
     long initialDelay, //首次执行延时
     long delay, //前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）
     TimeUnit unit //所设置的时间的计时单位，如TimeUnit.SECONDS常量
 );
```

当被调任务的执行时间大于指定的间隔时间时，ScheduleExecutorService 并不会创建一个新的线程去并发执行这个任务，而是等待前一次调度执行完毕。

“可调度线程池”的适用场景：周期性地执行任务的场景。Spring Boot 中的任务调度器，底层借助了 JUC 的 ScheduleExecutorService“可调度线程池”实现，并且可以通过 `@Configuration` 配置类型的 Bean。

## 线程池的标准创建方式

大部分企业的开发规范都会禁止使用快捷线程池（具体原因稍后介绍），要求通过标准构造器 ThreadPoolExecutor 去构造工作线程池。Executors 工厂类中创建线程池的快捷工厂方法实际上是调用
ThreadPoolExecutor（定时任务使用 ScheduledThreadPoolExecutor）线程池的构造方法完成的。`ThreadPoolExecuutor` 构造方法有多个重载版本，其中一个比较重要的构造器如下：

```java
// 使用标准构造器构造一个普通的线程池
 public ThreadPoolExecutor(
     int corePoolSize, // 核心线程数，即使线程空闲（Idle），也不会回收
     int maximumPoolSize, // 线程数的上限
     long keepAliveTime, TimeUnit unit, // 线程最大空闲（Idle）时长
     BlockingQueue<Runnable> workQueue, // 任务的排队队列
     ThreadFactory threadFactory, // 新线程的产生方式
     RejectedExecutionHandler handler // 拒绝策略
)
```

### 核心和最大线程数量

参数 `corePoolSize` 用于设置核心（Core）线程池数量，参数 `maximumPoolSiz` e 用于设置最大线程数量。线程池执行器将会根据 `corePoolSize` 和 `maximumPoolSize` 自动维护线程池中的工作线程，大致
规则为：

1. 当在线程池接收到新任务，并且当前工作线程数少于 `corePoolSize` 时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求，直到线程数达到 corePoolSize。（
2. 如果当前工作线程数多于 `corePoolSize` 数量，但小于 `maximumPoolSize` 数量，那么 **仅当任务排队队列已满时才会创建新线程**。通过设置 `corePoolSize` 和 `maximumPoolSize` 相同，可以创建一个固
   定大小的线程池。
3. 当 `maximumPoolSize` 被设置为无界值（如 `Integer.MAX_VALUE`）时，线程池可以接收任意数量的并发任务。
4. `corePoolSize` 和 `maximumPoolSize` 不仅能在线程池构造时设置，也可以调用 `setCorePoolSize()` 和 `setMaximumPoolSize()` 两个方法进行动态更改。

### BlockingQueue

BlockingQueue（阻塞队列）的实例用于暂时接收到的异步任务，如果线程池的核心线程都在忙，那么所接收到的目标任务缓存在阻塞队列中。

### keepAliveTime

线程构造器的 keepAliveTime（空闲线程存活时间）参数用于设置池内线程最大 Idle（空闲）时长（或者说保活时长），如果超过这个时间，默认情况下 Idle、非 Core 线程会被回收。

如果池在使用过程中提交任务的频率变高，也可以调用方法 setKeepAliveTime(long，TimeUnit)进行线程存活时间的动态调整，可以将时长延长。如果需要防止 Idle 线程被终止，可以将 Idle 时间设
置为无限大，具体如下：`setKeepAliveTime(Long.MAX_VALUE，TimeUnit.NANOSECONDS);`

默认情况下，Idle 超时策略仅适用于存在超过 corePoolSize 线程的情况。但若调用了 `allowCoreThreadTimeOut(boolean)` 方法，并且传入了参数 true，则 keepAliveTime 参数所设置的 Idle 超时策略也将被应用于核心线程。

`keepAliveTime` 的设定与线程的实际执行时间是两个独立的概念。`keepAliveTime` 是 **用于控制当线程数量已经小于核心线程数时，在无新任务提交的情况下空闲线程的存活时间**。

## 线程池提交任务的两种方式

> 在 ThreadPoolExecutor 类的实现中，内部核心的任务提交方法是 execute()方法，虽然用户程序通过 submit()也可以提交任务，但是实际上 submit()方法中最终调用的还是 execute()方法。

向线程池提交任务的两种方式大致如下：

- 方式一：调用 execute()方法，例如：

  ```java
   void execute(Runnable command);
  ```

- 方式二：调用 submit()方法，例如：

  ```java
   //ExecutorService 接口中的方法
   <T> Future<T> submit(Callable<T> task);
   <T> Future<T> submit(Runnable task, T result);
   Future<?> submit(Runnable task);
  ```

以上的 submit()和 execute()两类方法的区别在哪里呢？大致有以下三点：

1. 二者所接收的参数不一样
   **Execute()方法只能接收 Runnable 类型的参数，而 submit()方法可以接收 Callable、Runnable 两种类型的参数。**
   - Callable 类型的任务是可以返回执行结果的，而 Runnable 类型的任务不可以返回执行结果。
   - Callable 是 JDK 1.5 加入的执行目标接口，作为 Runnable 的一种补充，允许有返回值，允许抛出异常。
   - Runnable 和 Callable 的主要区别为：Callable 允许有返回值，Runnable 不允许有返回值；Runnable 不允许抛出异常，Callable 允许抛出异常。
2. **submit()提交任务后会有返回值**，而 execute()没有
   - execute()方法主要用于启动任务的执行，而任务的执行结果和可能的异常调用者并不关心。
   - submit()方法也用于启动任务的执行，但是启动之后会返回 Future 对象，代表一个异步执行实例，可以通过该异步执行实例去获取结果。
3. **submit()方便 Exception 处理**
   - execute()方法在启动任务执行后，任务执行过程中可能发生的异常调用者并不关心。
   - 而通过 submit()方法返回的 Future 对象（异步执行实例），可以进行异步执行过程中的异常捕获。

### submit()获取结果

submit()方法自身并不会传递结果，而是返回一个 Future 异步执行实例，处理过程的结果被包装到 Future 实例中，调用者可以通过 Future.get()方法获取异步执行的结果。通过 submit()返回的 Future
对象获取异步执行结果，演示代码如下：

```java
package pers.fulsun;

import java.util.concurrent.*;

public class ThreadPoolExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建一个线程池
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        try {
            // 提交任务并获取 Future 对象
            Future<Integer> future = executorService.submit(new MyCallable());

            // 检查任务是否完成
            if (future.isDone()) {
                System.out.println("Task is already done.");
            }

            // 获取任务的结果，阻塞直到结果可用
            int result = future.get();
            System.out.println("Result of the task: " + result);
        } finally {
            // 关闭线程池
            executorService.shutdown();
        }
    }

    static class MyCallable implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            Thread.sleep(2000); // 模拟耗时操作
            int result = 42;   // 模拟任务结果
            System.out.println("Task completed with result: " + result);
            return result;
        }
    }
}
```

### submit()捕获异常

submit()方法自身并不会传递结果，而是返回一个 Future 异步执行实例，处理过程的结果被包装到 Future 实例中，调用者可以通过 Future.get()方法获取异步执行的结果。**如果异常抛出，就会在调用 Future.get()时传递给调用者**, 通过 submit()返回的 Future 对象获取异步执行结果，演示代码如下：

```java
import java.util.concurrent.*;

public class ThreadPoolExample {

    public static void main(String[] args) {
        // 创建一个线程池
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        try {
            // 提交任务并获取 Future 对象
            Future<Integer> future = executorService.submit(new MyCallable());

            // 检查任务是否完成
            if (future.isDone()) {
                System.out.println("Task is already done.");
            }

            // 获取任务的结果，阻塞直到结果可用
            try {
                int result = future.get();
                System.out.println("Result of the task: " + result);
            } catch (InterruptedException | ExecutionException e) {
                System.err.println("Exception while getting the result: " + e.getMessage());
            }
        } finally {
            // 关闭线程池
            executorService.shutdown();
        }
    }

    static class MyCallable implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            Thread.sleep(2000); // 模拟耗时操作
            int result = 42;   // 模拟任务结果
            System.out.println("Task completed with result: " + result);
            return result;
        }
    }
}
```

## 线程池的任务调度流程

线程池的任务调度流程（包含接收新任务和执行下一个任务）大致如下：

1. 如果当前工作线程数量小于核心线程数量，执行器总是优先创建一个任务线程，而不是从线程队列中获取一个空闲线程。
2. 如果线程池中总的任务数量大于核心线程池数量，新接收的任务将被加入阻塞队列中，一直到阻塞队列已满。在核心线程池数量已经用完、阻塞队列没有满的场景下，线程池不会为新任务创建一个新线程。
3. 当完成一个任务的执行时，执行器总是优先从阻塞队列中获取下一个任务，并开始执行，一直到阻塞队列为空，其中所有的缓存任务被取光。
4. 在核心线程池数量已经用完、阻塞队列也已经满了的场景下，如果线程池接收到新的任务，将会为新任务创建一个线程（非核心线程），并且立即开始执行新任务。
5. 在核心线程都用完、阻塞队列已满的情况下，一直会创建新线程去执行新任务，直到池内的线程总数超出 maximumPoolSize。如果线程池的线程总数超过 maximumPoolSize，线程池就会拒绝接收任务，当新任务过来时，会为新任务执行拒绝策略。

![](/resources/b704e8df8fa042aea81a4844fa9f77e2.png)

## ThreadFactory（线程工厂）

`ThreadFactory` 是一个接口，它提供了创建线程的工厂方法。`ThreadFactory` 接口有一个单一的方法 `newThread(Runnable r)`，该方法用于创建一个新的 `Thread` 对象，这个线程将要执行给定的 `Runnable` 任务。`ThreadFactory` 的主要目的是提供一种统一的方式来创建线程，这样可以更容易地控制和管理这些线程，尤其是在线程池（如 `ExecutorService` 或 `Executors` 工具类中的线程池实现）中使用时。具体如下：

```java
public interface ThreadFactory {

    /**
     * Constructs a new unstarted {@code Thread} to run the given runnable.
     *
     * @param r a runnable to be executed by new thread instance
     * @return constructed thread, or {@code null} if the request to
     *         create a thread is rejected
     *
     * @see <a href="../../lang/Thread.html#inheritance">Inheritance when
     * creating threads</a>
     */
    Thread newThread(Runnable r);
}
```

在调用 ThreadFactory 的唯一方法 `newThread()` 创建新线程时，可以更改所创建的新线程的名称、线程组、优先级、守护进程状态等。
如果 newThread()的返回值为 null，表示线程工厂未能成功创建线程，线程池可能无法执行任何任务。

使用 Executors 创建新的线程池时，也可以基于 `ThreadFactory`（线程工厂）创建，在创建新线程池时可以指定将要使用的 ThreadFactory 实例。只不过，如果没有指定的话，就会使用
`Executors.defaultThreadFactory()` 默认实例。使用默认的线程工厂实例所创建的线程全部位于同一个 ThreadGroup（线程组）中，具有相同的 NORM\_PRIORITY（优先级为 5）

### 自定义 ThreadFactory 实例

基于自定义的 ThreadFactory 实例创建线程池，首先需要实现一个 `ThreadFactory` 类，实现其唯一的抽象方法 `newThread(Runnable)`。下面的例子首先实现一个简单的线程工厂，然后基于该线程工厂快捷创建线程池，具体的代码如下：

```java
public class MyThreadFactory implements ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;
    private final ThreadGroup threadGroup;
    private final int priority;
    private final boolean daemon;

    public MyThreadFactory(String prefix, ThreadGroup group, int priority, boolean isDaemon) {
        this.namePrefix = prefix + "-";
        this.threadGroup = group;
        this.priority = priority;
        this.daemon = isDaemon;
    }

    @Override
    public Thread newThread(Runnable r) {
        return new Thread(threadGroup, r, namePrefix + threadNumber.getAndIncrement(), priority, daemon);
    }

    public static void main(String[] args) {
        // 定义线程池核心和最大线程数
        int numCores = Runtime.getRuntime().availableProcessors();

        MyThreadFactory myThreadFactory = new MyThreadFactory(
                "MyPool-",
                Thread.currentThread().getThreadGroup(),  // 使用当前线程组
                Thread.MAX_PRIORITY,                      // 设置优先级为最高
                false                                     // 不设置守护线程
        );

        // 创建 ExecutorService 实例
        ExecutorService executor = Executors.newFixedThreadPool(numCores, myThreadFactory);
        executor.execute(() -> {
            System.out.println(Thread.currentThread().getName()+ ":Hello, world!");
        });
    }
}

```

## 任务阻塞队列

Java 中的阻塞队列（`BlockingQueue`）与普通队列相比有一个重要的特点：**在阻塞队列为空时会阻塞当前线程的元素获取操作**。具体来说，在一个线程从一个空的阻塞队列中获取元素时线程会被阻塞，直到阻塞队列中有了元素；当队列中有元素后，被阻塞的线程会自动被唤醒（唤醒过程不需要用户程序干预）。

Java 线程池使用 `BlockingQueue` 实例暂时接收到的异步任务，`BlockingQueue` 是 JUC 包的一个超级接口，比较常用的实现类有：

1. `ArrayBlockingQueue`：是一个数组实现的有界阻塞队列（有界队列），队列中的元素按 FIFO 排序。`ArrayBlockingQueue` 在创建时必须设置大小，接收的任务超出 corePoolSize 数量时，任务被缓存到该阻塞队列中，**任务缓存的数量只能为创建时设置的大小**，若该阻塞队列已满，则会为新的任务创建线程，直到线程池中的线程总数大于 maximumPoolSize。
2. `LinkedBlockingQueue`：是一个基于链表实现的阻塞队列，按 FIFO 排序任务，可以设置容量（有界队列），不设置容量则默认使用 Integer.Max\_VALUE 作为容量（无界队列）。该队列的吞吐量高于 ArrayBlockingQueue。如果不设置 LinkedBlockingQueue 的容量（无界队列），当接收的任务数量超出 corePoolSize 时，则新任务可以被无限制地缓存到该阻塞队列中，直到资源耗尽。有两个快捷创建线程池的工厂方法 `Executors.newSingleThreadExecutor` 和 `Executors.newFixedThreadPool` 使用了这个队列，并且都没有设置容量（无界队列）。
3. `PriorityBlockingQueue`：是具有优先级的无界队列。
4. `DelayQueue`：这是一个无界阻塞延迟队列，底层基于 `PriorityBlockingQueue` 实现，队列中每个元素都有过期时间，当从队列获取元素（元素出队）时，只有已经过期的元素才会出队，队列头部的元素是过期最快的元素。快捷工厂方法 `Executors.newScheduledThreadPool` 所创建的线程池使用此队列。
5. `SynchronousQueue`：（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程的调用移除操作，否则插入操作一直处于阻塞状态，其吞吐量通常高于 `LinkedBlockingQueue`。快捷工厂方法 `Executors.newCachedThreadPool` 所创建的线程池使用此队列。与前面的队列相比，这个队列比较特殊，它不会保存提交的任务，而是直接新建一个线程来执行新来的任务。

| 阻塞队列类型                    | 特点                                          | 用途                       | 行为                                                         |
| ------------------------- | ------------------------------------------- | ------------------------ | ---------------------------------------------------------- |
| **ArrayBlockingQueue**    | 基于数组的有界阻塞队列。提供固定大小的缓冲区来存储元素。                | 适合创建时即确定任务数量的情况使用。       | 线程在添加元素到已满的队列时会被挂起；从空队列中获取元素时被挂起；当队列为空或已满时，线程会自动唤醒并继续执行操作。 |
| **LinkedBlockingQueue**   | 基于链表的阻塞队列。提供无界（可配置大小）或有界的缓冲区来存储元素。          | 适合任务数量不确定或很大的情况使用。       | 线程在添加元素到已满的队列时会被挂起；从空队列中获取元素时被挂起；当队列为空或已满时，线程会自动唤醒并继续执行操作。 |
| **PriorityBlockingQueue** | 有界的优先级队列，根据元素的优先级排序。                        | 适合需要对任务进行排序以按优先级执行的情况使用。 | 线程在从空队列中获取元素时会被挂起；当队列中有新的高优先级元素被添加时，会自动唤醒等待的线程。            |
| **DelayQueue**            | 基于 `PriorityBlockingQueue` 实现，每个元素都有一个过期时间。 | 用于在指定的时间后才能被取走的任务。       | 线程在从空队列中获取元素时会被挂起；当队列中的最早过期元素被移除时，会自动唤醒等待的线程。              |
| **SynchronousQueue**      | 不存储元素的阻塞队列。即每个插入操作必须等到另一个线程调用移除操作，否则会一直阻塞。  | 适合任务立即执行或直接调度到工作线程的情况使用。 | 线程在尝试从空队列中获取元素时会被挂起；当有其他线程添加元素时，等待的线程会被自动唤醒并继续执行操作。        |

- **内部实现**：
  - `ArrayBlockingQueue`：使用一个循环数组来实现有界阻塞队列，并通过 `synchronized` 方法和 `wait()`、`notifyAll()` 机制来管理线程的挂起与唤醒。
  - `LinkedBlockingQueue`：使用单向链表结构，内部维护了两个 `Condition` 对象（一个用于获取操作，另一个用于添加操作），同样依赖于 `synchronized` 方法和 `wait()`、`notifyAll()` 机制来实现。
  - `PriorityBlockingQueue` 和 `DelayQueue` 等也类似地实现了基于锁和条件变量的线程管理。

## 调度器的钩子方法

ThreadPoolExecutor 线程池调度器为每个任务执行前后都提供了钩子方法。ThreadPoolExecutor 类提供了三个钩子方法（空方法），这三个钩子方法一般用作被子类重写，具体如下：

```java
//任务执行之前的钩子方法（前钩子）
 protected void beforeExecute(Thread t, Runnable r) { }
 //任务执行之后的钩子方法（后钩子）
 protected void afterExecute(Runnable r, Throwable t) { }
 //线程池终止时的钩子方法（停止钩子）
 protected void terminated() { }
```

> beforeExecute 和 afterExecute 两个方法在每个任务执行前后被调用，如果钩子（回调方法）引发异常，内部工作线程可能失败并突然终止。

### `beforeExecute`

线程池工作线程在异步 **执行目标实例（如 Runnable 实例）前调用此钩子方法**。此方法仍然由执行任务的工作线程调用。默认实现不执行任何操作，但可以在子类中对其进行自定义。

此方法由执行目标实例的工作线程调用，可用于重新初始化 ThreadLocal 线程本地变量实例、更新日志记录、开始计时统计、更新上下文变量等。

```java
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ScheduledThreadPoolExecutor;

public class ScheduledThreadPoolExample {
    public static void main(String[] args) {
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(4);

        // 自定义预执行钩子方法
        ThreadPoolExecutor.BeforeExecuteHook beforeExecuteHook = (t, r) -> System.out.println("Task is about to start on thread: " + t.getName());

        // 设置自定义的钩子方法
        executor.prestartAllCoreThreads();
        executor.beforeExecute(beforeExecuteHook);

        // 创建并提交任务
        for (int i = 0; i < 5; i++) {
            final int taskNumber = i;
            Runnable task = () -> System.out.println("Executing task: " + taskNumber);
            executor.schedule(task, i, java.util.concurrent.TimeUnit.SECONDS); // 每隔一秒执行一次任务
        }

        executor.shutdown();
    }
}
```

### `afterExecute`

线程池工作线程在异步 **执行目标实例后调用此钩子方法**。此方法仍然由执行任务的工作线程调用。此钩子方法的默认实现不执行任何操作，可以在调度器子类中对其进行自定义。

此方法由执行目标实例的工作线程调用，可用于清除 ThreadLocal 线程本地变量、更新日志记录、收集统计信息、更新上下文变量等。

```java
javaimport java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ScheduledThreadPoolExecutor;

public class ScheduledThreadPoolExample {
    public static void main(String[] args) {
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(4);

        // 自定义后执行钩子方法
        ThreadPoolExecutor.AfterExecuteHook afterExecuteHook = (t, r) -> System.out.println("Task has finished on thread: " + t.getName());

        // 设置自定义的钩子方法
        executor.prestartAllCoreThreads();
        executor.afterExecute(afterExecuteHook);

        // 创建并提交任务
        for (int i = 0; i < 5; i++) {
            final int taskNumber = i;
            Runnable task = () -> System.out.println("Executing task: " + taskNumber);
            executor.schedule(task, i, java.util.concurrent.TimeUnit.SECONDS); // 每隔一秒执行一次任务
        }

        executor.shutdown();
    }
}
```

### `terminated`

terminated 钩子方法在 Executor 终止时调用，默认实现不执行任何操作。

### 定制钩子方法

继承 `ThreadPoolExecutor` 类，并重写其中的几个钩子方法。

```java
public class CustomThreadPoolExecutor extends ThreadPoolExecutor {

    public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        if (r instanceof MeasuredTask) { // 假设我们的任务都是MeasuredTask类型，这个类可以保存开始时间。
            ((MeasuredTask)r).startTime = System.nanoTime(); // 用System.nanoTime()获取纳秒级别的精度
        }
    }

    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        if (r instanceof MeasuredTask) {
            long duration = System.nanoTime() - ((MeasuredTask)r).startTime;
            System.out.println("任务执行时间: " + duration / 1e6 + " ms"); // 将纳秒转换为毫秒输出
        }
    }

    @Override
    protected void terminated() {
        super.terminated();
        System.out.println("线程池已终止");
    }

}

java


import java.util.concurrent.*;

public class CustomThreadPoolExecutor extends ThreadPoolExecutor {

    public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        if (r instanceof MeasuredTask) { // 假设我们的任务都是MeasuredTask类型，这个类可以保存开始时间。
            ((MeasuredTask)r).startTime = System.nanoTime(); // 用System.nanoTime()获取纳秒级别的精度
        }
    }

    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        if (r instanceof MeasuredTask) {
            long duration = System.nanoTime() - ((MeasuredTask)r).startTime;
            System.out.println("任务执行时间: " + duration / 1e6 + " ms"); // 将纳秒转换为毫秒输出
        }
    }

    @Override
    protected void terminated() {
        super.terminated();
        System.out.println("线程池已终止");
    }

}

// 定义一个具体的任务类，继承自Runnable，并添加开始时间记录字段。
class MeasuredTask implements Runnable {
    long startTime; // 开始执行的时间点

    public MeasuredTask(Runnable task) {
        this.runnable = task;
    }

    private final Runnable runnable;

    @Override
    public void run() {
        runnable.run(); // 执行实际的任务逻辑
    }

}
```

## 线程池的拒绝策略

在线程池的任务缓存队列为有界队列（有容量限制的队列）的时候，如果队列满了，提交任务到线程池的时候就会被拒绝。总体来说，任务被拒绝有两种情况：

1. 线程池已经被关闭。
2. 工作队列已满且 maximumPoolSize 已满。

无论以上哪种情况任务被拒绝，线程池都会调用 `RejectedExecutionHandler` 实例的 `rejectedExecution` 方法。

RejectedExecutionHandler 是拒绝策略的接口，JUC 为该接口提供了以下几种实现：

1. `AbortPolicy`：拒绝策略。
2. `DiscardPolicy`：抛弃策略。
3. `DiscardOldestPolicy`：抛弃最老任务策略。
4. `CallerRunsPolicy`：调用者执行策略。
5. 自定义策略。

### AbortPolicy

这是默认策略，当线程池队列已满并且无法容纳更多任务时抛出异常。

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,  // 核心线程数
    20, // 最大线程数
    60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    new AbortPolicy()
);
```

### CallerRunsPolicy

当任务无法添加到线程池时，它由提交该任务的线程执行，不会使用线程池中的线程去执行新任务。这可以降低新任务的数量或提高正在运行的任务完成的速度。

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,
    20,
    60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    new CallerRunsPolicy()
);
```

### DiscardPolicy

当任务无法添加到线程池时，直接丢弃该任务。不抛出异常或给出任何通知。

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,
    20,
    60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    new DiscardPolicy()
);
```

### DiscardOldestPolicy

当任务无法添加到线程池时，丢弃队列中最旧的任务，并尝试重新插入新任务。因为队列是队尾进队头出，队头元素是最老的，所以每次都是移除队头元素后再尝试入队。

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,
    20,
    60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    new DiscardOldestPolicy()
);
```

### 自定义拒绝策略

除了使用内置的拒绝策略，你还可以创建自定义类来实现 `RejectedExecutionHandler` 接口，并通过构造方法或 `setRejectedExecutionHandler()` 方法将该对象设置为线程池的工作参数。

下面是一个简单的示例，展示了如何创建一个自定义的拒绝策略：

```java
public class CustomRejectPolicy implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 打印一条日志信息或执行其他操作来处理被拒绝的任务
        System.err.println("任务被线程池拒绝: " + r.toString());
    }
}

// 使用自定义的拒绝策略创建线程池
ThreadPoolExecutor customPool = new ThreadPoolExecutor(
    5,
    20,
    60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    new CustomRejectPolicy()
);
```

## 线程池的优雅关闭

一般情况下，线程池启动后建议手动关闭。在介绍线程池的优雅关闭之前，我们先了解一下线程池的状态。线程池总共存在 5 种状态，定义在 `ThreadPoolExecutor` 类中，具体代码如下：

```java
    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
```

线程池的 5 种状态具体如下：

1. `RUNNING`：线程池创建之后的初始状态，这种状态下可以执行任务。
2. `SHUTDOWN`：该状态下线程池不再接受新任务，但是会将工作队列中的任务执行完毕。
3. `STOP`：该状态下线程池不再接受新任务，也不会处理工作队列中的剩余任务，并且将会中断所有工作线程。
4. `TIDYING`：该状态下所有任务都已终止或者处理完成，将会执行 terminated()钩子方法。
5. `TERMINATED`：执行完 `terminated()` 钩子方法之后的状态

线程池的状态转换规则为：

1. 线程池创建之后状态为 `RUNNING`。
2. 执行线程池的 `shutdown()` 实例方法，会使线程池状态从 `RUNNING` 转变为 `SHUTDOWN`。
3. 执行线程池的 `shutdownNow()` 实例方法，会使线程池状态从 `RUNNING` 转变为 `STOP`。
4. 当线程池处于 SHUTDOWN 状态时，执行其 `shutdownNow()` 方法会将其状态转变为 `STOP`。
5. 等待线程池的所有工作线程停止，工作队列清空之后，线程池状态会从 STOP 转变为 `TIDYING`。
6. 执行完 `terminated()` 钩子方法之后，线程池状态从 `TIDYING` 转变为 `TERMINATED`。

优雅地关闭线程池主要涉及的方法有 3 个：

1. `shutdown`：是 JUC 提供的一个有序关闭线程池的方法，此方法会 **等待当前工作队列中的剩余任务全部执行完成之后，才会执行关闭**，但是此方法被调用之后线程池的状态转为 SHUTDOWN，线程池不会再接收新的任务。
2. `shutdownNow`：是 JUC 提供的一个立即关闭线程池的方法，此方法会打断正在执行的工作线程，并且会清空当前工作队列中的剩余任务，返回的是尚未执行的任务。
3. `awaitTermination`：等待线程池完成关闭。在调用线程池的 `shutdown()` 与 `shutdownNow()` 方法时，当前线程会立即返回，不会一直等待直到线程池完成关闭。如果需要等到线程池关闭完成，可以调用 `awaitTermination()` 方法。

### shutdown()方法的原理

Shutdown()方法首先加锁，其次检查调用者是否用于执行线程池关闭的 Java Security 权限。接着 shutdown()方法会将线程池状态变为 SHUTDOWN，在这之后线程池不再接受提交的新任务。此时如果还继续往线程池提交任务，将会使用线程池拒绝策略响应，默认的拒绝策略将会使用 ThreadPoolExecutor.AbortPolicy，接收新任务时会抛出 RejectedExecutionException 异常。

`shutdown()` 方法的源码大致如下：

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 检查权限
        checkShutdownAccess();
        // 设置线程池状态
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptIdleWorkers();
        // 钩子函数，主要用于清理一些资源
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}

```

### shutdownNow()方法的原理

`shutdownNow()` 方法将会把线程池状态设置为 STOP，然后中断所有线程（包括工作线程以及空闲线程），最后清空工作队列，取出工作队列所有未完成的任务返回给调用者。与有序的 shutdown()方法相比，**`shutdownNow()方法比较粗暴，直接中断工作线程`**。不过这里需要注意的是，中断线程并不代表线程立刻结束，只是通过工作线程的 interrupt()实例方法设置了中断状态，这里需要用户程序主动配合线
程进行中断操作。

`shutdownNow()` 方法的源码大致如下

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 检查状态
        checkShutdownAccess(); // 将线程池状态变为 STOP
        advanceRunState(STOP);
        // 中断所有线程，包括工作线程以及空闲线程
        interruptWorkers();
        // 丢弃工作队列中的剩余任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```

### awaitTermination()方法的使用

调用了线程池的 shutdown()与 shutdownNow()方法之后，用户程序都不会主动等待线程池关闭完成，**如果需要等待线程池关闭完成，需要调用 awaitTermination()进行主动等待**。调用方法大致如下

```java
threadPool.shutdown();
try {
    // 一直等待，直到线程池完成关闭
    while
    (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
        System.out.println("线程池任务还未执行结束");
    }
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

如果线程池完成关闭，awaitTermination()方法将会返回 true，否则当等待时间超过指定时间后将会返回 false。如果需要调用 awaitTermination()，**建议不是永久等待，而是设置一定重试次数**。
下面的代码参考了阿里巴巴著名的分布式框架 Dubbo 框架中线程池关闭源码中的部分代码：

```java
if (!threadPool.isTerminated()) {
    try {
        for (int i = 0; i < 1000; i++) // 循环关闭1000次，每次等待10毫秒
        {
            if (threadPool.awaitTermination(10,
                    TimeUnit.MILLISECONDS)) {
                break;
            }
            threadPool.shutdownNow();
        }
    } catch (InterruptedException e) {
        System.err.println(e.getMessage());
    } catch (Throwable e) {
        System.err.println(e.getMessage());
    }
}
```

### 优雅地关闭线程池

可以结合 shutdown()、shutdownNow()、awaitTermination()三个方法优雅地关闭一个线程池，大致分为以下几步：

1. 执行 shutdown()方法，拒绝新任务的提交，并等待所有任务有序地执行完毕。
2. 执行 awaitTermination(long timeout, TimeUnit unit)方法，指定超时时间，判断是否已经关闭所有任务，线程池关闭完成。
3. 如果 awaitTermination()方法返回 false，或者被中断，就调用 shutDownNow()方法立即关闭线程池所有任务。
4. 补充执行 awaitTermination(long timeout, TimeUnit unit)方法，判断线程池是否关闭完成。如果超时，就可以进入循环关闭，循环一定的次数（如 1000 次），不断关闭线程池，直到其关闭或者循
   环结束。

```java
package pers.fulsun;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

public class ThreadUtil {
    public static void shutdownThreadPoolGracefully(ExecutorService threadPool) {
        // 若已经关闭则返回
        if (!(threadPool instanceof ExecutorService) || threadPool.isTerminated()) {
            return;
        }
        try {
            threadPool.shutdown(); // 拒绝接受新任务
        } catch (SecurityException e) {
            return;
        } catch (NullPointerException e) {
            return;
        }
        try {
            // 等待60秒，等待线程池中的任务完成执行
            if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
                // 调用 shutdownNow() 方法取消正在执行的任务
                threadPool.shutdownNow();
                // 再次等待60秒，如果还未结束，可以再次尝试，或者直接放弃
                if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
                    System.err.println("线程池任务未正常执行结束");
                }
            }
        } catch (InterruptedException ie) {
            // 捕获异常，重新调用 shutdownNow() 方法
            threadPool.shutdownNow();
        }
        // 仍然没有关闭，循环关闭1000次，每次等待10毫秒
        if (!threadPool.isTerminated()) {
            try {
                for (int i = 0; i < 1000; i++) {
                    if (threadPool.awaitTermination(10, TimeUnit.MILLISECONDS)) {
                        break;
                    }
                    threadPool.shutdownNow();
                }
            } catch (InterruptedException e) {
                System.err.println(e.getMessage());
            } catch (Throwable e) {
                System.err.println(e.getMessage());
            }
        }
    }
}

```

### 注册 JVM 钩子函数自动关闭线程池

如果使用了线程池，可以在 JVM 中注册一个钩子函数，在 JVM 进程关闭之前，由钩子函数自动将线程池优雅地关闭，以确保资源正常释放

```java
static class SeqOrScheduledTargetThreadPoolLazyHolder {
    // 线程池：用于定时任务、顺序排队执行任务
    static final ScheduledThreadPoolExecutor EXECUTOR = new ScheduledThreadPoolExecutor(1, new CustomThreadFactory("seq"));

    static {
        // 注册JVM关闭时的钩子函数
        Runtime.getRuntime().addShutdownHook(new ShutdownHookThread("定时和顺序任务线程池", (Callable<Void>) () -> {
            // 优雅地关闭线程池
            shutdownThreadPoolGracefully(EXECUTOR);
            return null;
        }));
    }
}
```

## Executors 快捷创建线程池的潜在问题

在很多公司（如阿里、华为等）的编程规范中，非常明确地禁止使用 Executors 快捷创建线程池，为什么呢？这里从源码讲起，介绍使用 Executors 工厂方法快捷创建线程池将会面临的潜在问题。

### newFixedThreadPool

使用 Executors 创建“固定数量的线程池”的潜在问题使用 newFixedThreadPool 工厂方法创建“固定数量的线程池”的源码如下：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, // 核心线程数 最大线程数
                                  0L, TimeUnit.MILLISECONDS, // 线程最大空闲（Idle）时长 时间单位：毫秒
                                  new LinkedBlockingQueue<Runnable>()); //任务的排队队列，无界队列
}
```

newFixedThreadPool 工厂方法返回一个 ThreadPoolExecutor 实例，该线程池实例的 corePoolSize 数量为参数 nThread，其 maximumPoolSize 数量也为参数 nThread，其 workQueue 属性的值为 `LinkedBlockingQueue<Runnable>()` 无界阻塞队列。使用 Executors 创建“固定数量的线程池”的潜在问题主要存在于其 workQueue 上，其值为 LinkedBlockingQueue（无界阻塞队列）。**如**
**果任务提交速度持续大于任务处理速度，就会造成队列中大量的任务等待。如果队列很大，很有可能导致 JVM 出现 OOM**（Out Of Memory）异常，即内存资源耗尽.

### newSingleThreadExecutor

```java
    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new AutoShutdownDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(), //无界队列
                                    threadFactory));
    }
```

使用 Executors 创建的“单线程化线程池”与“固定大小的线程池”一样，其潜在问题仍然存在于其 workQueue 属性上，该属性的值为 LinkedBlockingQueue（无界阻塞队列）。如果任务提交速度持续大于任务处理速度，就会造成队列大量阻塞。如果队列很大，很有可能导致 JVM 的 OOM 异常，甚至造成内存资源耗尽。

### newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

以上代码通过调用 ThreadPoolExecutor 标准构造器创建一个核心线程数为 0、最大线程数不设限制的线程池。所以，理论上“可缓存线程池”可以拥有无数个工作线程，即线程数量几乎无限制。“可缓存线程池”的 workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，正因为“可缓存线程池”可以无限制地创建线程，不会有任务等待，所以才使用 SynchronousQueue。使用 Executors 创建的“可缓存线程池”的潜在 **问题存在于其最大线程数量不设上限**。由于其 maximumPoolSize 的值为 `Integer.MAX_VALU` E（非常大），可以认为可以无限创建线程，如果任务提交较多，就会造成大量的线程被启动，很有可能造成 OOM 异常，甚至导致 CPU 线程资源耗尽。

### newScheduledThreadPool

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
```

Executors 的 newScheduledThreadPool 工厂方法调用了 ScheduledThreadPoolExecutor 实现类的构造器，而 ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor 的普通线程池类，在其构造器内部进一步调用了该父类的构造器，具体的代码如下：

```java

public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE,
          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
          new DelayedWorkQueue());
}
```

> ScheduledThreadPoolExecutor#execute

```java
// java.util.concurrent.ScheduledThreadPoolExecutor#execute
public void execute(Runnable command) {
    schedule(command, 0, NANOSECONDS);
}
// java.util.concurrent.ScheduledThreadPoolExecutor#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit)
public ScheduledFuture<?> schedule(Runnable command,
                                   long delay,
                                   TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    RunnableScheduledFuture<Void> t = decorateTask(command,
        new ScheduledFutureTask<Void>(command, null,
                                      triggerTime(delay, unit),
                                      sequencer.getAndIncrement()));
    delayedExecute(t);
    return t;
}

// java.util.concurrent.ScheduledThreadPoolExecutor#delayedExecute
private void delayedExecute(RunnableScheduledFuture<?> task) {
    if (isShutdown())
        reject(task);
    else {
        super.getQueue().add(task);
        if (!canRunInCurrentRunState(task) && remove(task))
            task.cancel(false);
        else
            ensurePrestart();
    }
}

// java.util.concurrent.ThreadPoolExecutor#ensurePrestart
void ensurePrestart() {
    int wc = workerCountOf(ctl.get());
    if (wc < corePoolSize)
        addWorker(null, true);
    else if (wc == 0)
        addWorker(null, false);
}
```

以上代码创建了一个 ThreadPoolExecutor 实例，其 corePoolSize 为传递来的参数，maximumPoolSize 为 Integer.MAX\_VALUE，表示线程数不设上限，其 workQueue 为一个 DelayedWorkQueue 实例，这是一个按到期时间升序排序的阻塞队列。~~使用 Executors 创建的“可缓存线程池”的潜在问题存在于其最大线程数量不设限上。由于其线程数量不设限，如果到期任务太多，就会导致 CPU 的线程资源耗尽~~。

通过分析 execute 方法的源码 ensurePrestart 方法，线程最大只有 corePoolsize 个，不会创建过多的线程。虽然 DelayedWorkQueue 可以存储一些任务，如果任务提交速度持续大于任务处理速度，会造成 workQueue 队列中大量的任务等待。如果队列很大，很有可能导致 JVM 出现 OOM 异常，甚至造成内存资源耗尽。

## 确定线程池的线程数

使用线程池的好处主要有以下三点：

1. 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。
2. 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。
3. 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。

虽然使用线程池的好处很多，但是如果其线程数配置得不合理，不仅可能达不到预期效果，反而可能降低应用的性能

### 按照任务类型对线程池进行分类

使用标准构造器 ThreadPoolExecutor 创建线程池时，会涉及线程数的配置，而线程数的配置与异步任务类型是分不开的。这里将线程

池的异步任务大致分为以下三类：

1. IO 密集型任务
   - 此类任务主要是执行 IO 操作。由于执行 IO 操作的时间较长，导致 CPU 的利用率不高，这类任务 CPU 常处于空闲状态。Netty 的 IO 读写操作为此类任务的典型例子。
2. CPU 密集型任务
   - 此类任务主要是执行计算任务。由于响应时间很快，CPU 一直在运行，这种任务 CPU 的利用率很高。
3. 混合型任务
   - 此类任务既要执行逻辑计算，又要进行 IO 操作（如 RPC 调用、数据库访问）。相对来说，由于执行 IO 操作的耗时较长（一次网络往返往往在数百毫秒级别），这类任务的 CPU 利用率也不是太高。Web 服务器的 HTTP 请求处理操作为此类任务的典型例子。

一般情况下，针对以上不同类型的异步任务需要创建不同类型的线程池，并进行针对性的参数配置。

### 为 IO 密集型任务确定线程数

由于 IO 密集型任务的 CPU 使用率较低，导致线程空余时间很多，因此 **通常需要开 CPU 核心数两倍的线程**。当 IO 线程空闲时，可以启用其他线程继续使用 CPU，以提高 CPU 的使用率。
Netty 的 IO 处理任务就是典型的 IO 密集型任务。所以，Netty 的 Reactor（反应器）实现类（定制版的线程池）的 IO 处理线程数默认正好为 CPU 核数的两倍，以下是其相关的代码：

```java
// 多线程版本Reactor实现类
public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup {

    // IO事件处理线程数
    private static final int DEFAULT_EVENT_LOOP_THREADS;

    // IO事件处理线程数默认值为CPU核数的两倍
    static {
        DEFAULT_EVENT_LOOP_THREADS = Math.max(1,

                SystemPropertyUtil.getInt("io.netty.eventLoopThreads",

                        Runtime.getRuntime().availableProcessors() * 2));
    }

    /**
     * 构造器
     */
    protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
    }
}
```

### 为 CPU 密集型任务确定线程数

CPU 密集型任务也叫计算密集型任务，其特点是要进行大量计算而需要消耗 CPU 资源，比如计算圆周率、对视频进行高清解码等。CPU 密集型任务虽然也可以并行完成，但是并行的任务越多，花在任务切换的时间就越多，CPU 执行任务的效率就越低，所以要最高效地利用 CPU，**CPU 密集型任务并行执行的数量应当等于 CPU 的核心数**。

比如 4 个核心的 CPU，通过 4 个线程并行地执行 4 个 CPU 密集型任务，此时的效率是最高的。但是如果线程数远远超出 CPU 核心数量，就需要频繁地切换线程，线程上下文切换时需要消耗时间，反而会使得任务效率下降。因此，对于 CPU 密集型的任务来说，线程数等于 CPU 数就行。

### 为混合型任务确定线程数

混合型任务既要执行逻辑计算，又要进行大量非 CPU 耗时操作（如 RPC 调用、数据库访问、网络通信等），所以混合型任务 CPU 的利用率不是太高，非 CPU 耗时往往是 CPU 耗时的数倍。比如在 Web 应用中处理 HTTP 请求时，一次请求处理会包括 DB 操作、RPC 操作、缓存操作等多种耗时操作。一般来说，一次 Web 请求的 CPU 计算耗时往往较少，大致在 100 ～ 500 毫秒，而其他耗时操作会占用 500 ～ 1000 毫秒，甚至更多的时间。

在为混合型任务创建线程池时，如何确定线程数呢？业界有一个比较成熟的估算公式，具体如下：`最佳线程数 = ((线程等待时间+线程CPU时间) / 线程CPU时间) * CPU核数`, 经过简单的换算，以上公式可进一步转换为：`最佳线程数目 = (线程等待时间与线程CPU时间之比 + 1) * CPU核数`

通过公式可以看出：等待时间所占的比例越高，需要的线程就越多；CPU 耗时所占的比例越高，需要的线程就越少。下面举一个例子：比如在 Web 服务器处理 HTTP 请求时，假设平均线程 CPU 运行时间为 100 毫秒，而线程等待时间（比如包括 DB 操作、RPC 操作、缓存操作等）为 900 毫秒，如果 CPU 核数为 8，那么根据上面这个公式，估算如下：`(900毫秒 + 100毫秒) / 100毫秒 * 8 = 10 * 8 = 80`

在使用如上代码创建混合型线程池时，建议按照前面的最佳线程数估算公式提前预估好线程数（如 80），然后设置在环境变量 `mixed.thread.amount` 中，测试用例如下：

### 工具类

```java
import java.util.concurrent.*;

public class ThreadPoolManager {

    private static final int CPU_MAX = Runtime.getRuntime().availableProcessors();
    private static final int IO_MAX = 2 * CPU_MAX; // I/O密集型任务可以使用更大的线程池
    private static final String MIXED_THREAD_AMOUNT = "mixed.thread.amount";
    private static final int MIXED_MAX = 128;

    /**
     * 混合型任务的线程池单例。
     */
    private static class MixedTargetThreadPoolLazyHolder {
        private static final ExecutorService executor;

        static {
            int maxThreads = Integer.parseInt(System.getProperty(MIXED_THREAD_AMOUNT, String.valueOf(MIXED_MAX)));
            // 创建一个可调整大小的线程池，根据任务的需求动态增加或减少线程。
            executor = new ThreadPoolExecutor(
                Runtime.getRuntime().availableProcessors(),  // 核心线程数
                maxThreads,                               // 最大线程数
                60L,                                      // 空闲时间后核心线程的存活时间（秒）
                TimeUnit.SECONDS,                         // 时间单位
                new LinkedBlockingQueue<>(128),            // 队列大小，可根据需要调整
                new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略：主线程执行任务
            );
        }
    }

    /**
     * 获取混合型任务的线程池实例。
     *
     * @return ExecutorService 线程池实例
     */
    public static synchronized ExecutorService getMixedThreadPool() {
        return MixedTargetThreadPoolLazyHolder.executor;
    }

    /**
     * 获取CPU密集型任务的线程池实例。
     *
     * @return ExecutorService 线程池实例
     */
    private static final class CpuIntensiveThreadPoolLazyHolder {
        private static final ExecutorService executor;

        static {
            int maxThreads = CPU_MAX;
            executor = new ThreadPoolExecutor(
                maxThreads,                                 // 核心线程数
                maxThreads,                                 // 最大线程数，CPU密集型任务保持较小的线程池大小以减少资源消耗
                60L,                                        // 空闲时间后核心线程的存活时间（秒）
                TimeUnit.SECONDS,                           // 时间单位
                new LinkedBlockingQueue<>(128)              // 队列大小，可根据需要调整
            );
        }
    }

    public static ExecutorService getCpuIntensiveThreadPool() {
        return CpuIntensiveThreadPoolLazyHolder.executor;
    }

    /**
     * 获取I/O密集型任务的线程池实例。
     *
     * @return ExecutorService 线程池实例
     */
    private static final class IoIntensiveThreadPoolLazyHolder {
        private static final ExecutorService executor;

        static {
            int maxThreads = IO_MAX;
            executor = new ThreadPoolExecutor(
                1,                                          // 核心线程数，保持较低的初始核心线程数以减少资源消耗
                maxThreads,                                 // 最大线程数，I/O密集型任务可以使用更大的线程池大小
                60L,                                        // 空闲时间后核心线程的存活时间（秒）
                TimeUnit.SECONDS,                           // 时间单位
                new LinkedBlockingQueue<>(128)              // 队列大小，可根据需要调整
            );
        }
    }

    public static ExecutorService getIoIntensiveThreadPool() {
        return IoIntensiveThreadPoolLazyHolder.executor;
    }

    /**
     * 关闭执行器，释放资源。
     *
     * @param executor 要关闭的ExecutorService
     */
    public static void shutdownExecutor(ExecutorService executor) {
        if (executor != null && !executor.isShutdown()) {
            executor.shutdown();
            try {
                // 给出合理的等待时间让所有任务执行完毕，然后终止线程池。
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    executor.shutdownNow(); // 强制关闭
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt(); // 恢复中断状态
            }
        }
    }

    public static void main(String[] args) {
        ExecutorService mixedExecutor = getMixedThreadPool();
        ExecutorService cpuExecutor = getCpuIntensiveThreadPool();
        ExecutorService ioExecutor = getIoIntensiveThreadPool();

        // 使用线程池执行任务...

        shutdownExecutor(mixedExecutor);
        shutdownExecutor(cpuExecutor);
        shutdownExecutor(ioExecutor); // 确保在适当的时候关闭执行器。
    }
}
```
